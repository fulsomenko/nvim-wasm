<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>nvim wasm demo</title>
    <style>
      :root { color-scheme: dark; }
      * { box-sizing: border-box; }
      body { margin: 0; background: #0b0f15; color: #e8edf5; font-family: system-ui, -apple-system, "Segoe UI", sans-serif; display: flex; justify-content: center; min-height: 100vh; }
      .app { width: min(960px, 100%); padding: 16px; display: flex; flex-direction: column; gap: 12px; }
      .status { font-weight: 600; }
      .grid { min-height: 480px; border: 1px solid #2a3346; border-radius: 10px; padding: 10px; background: #050912; color: #dfe5f1; font-family: "SFMono-Regular", Menlo, Consolas, monospace; font-size: 14px; line-height: 1.35; white-space: pre; overflow: auto; outline: none; }
      .grid:focus { border-color: #5ad1ff; }
      .cursor { background: transparent; color: inherit; }
      .hint { color: #9aa4b5; font-size: 12px; margin: 0; }
    </style>
  </head>
  <body>
    <div class="app">
      <div class="status" id="status">Loading...</div>
      <div class="hint" id="mode">mode: -</div>
      <div id="grid" class="grid" tabindex="0" aria-label="Neovim grid"></div>
      <p class="hint">Serve with COOP/COEP so SharedArrayBuffer works.</p>
    </div>

    <script type="module">
      import { encode } from "./msgpack.js";
      const statusEl = document.getElementById("status");
      const gridEl = document.getElementById("grid");
      const modeEl = document.getElementById("mode");
      const gridStyles = window.getComputedStyle(gridEl);
      const fallbackFg = gridStyles.color || "#dfe5f1";
      const fallbackBg = gridStyles.backgroundColor || "#050912";
      const WORKER_VERSION = "v1";
      const cols = 96;
      const rows = 32;
      let worker = null;
      let ring = null;
      let reqId = 0;
      let primeSent = false;
      let lastClipboard = "";

      class SharedInputWriter {
        constructor(capacity = 262144) {
          this.capacity = capacity;
          this.buffer = new SharedArrayBuffer(8 + capacity);
          this.ctrl = new Int32Array(this.buffer, 0, 2);
          this.data = new Uint8Array(this.buffer, 8);
          Atomics.store(this.ctrl, 0, 0);
          Atomics.store(this.ctrl, 1, 0);
        }
        push(bytes) {
          const src = bytes instanceof Uint8Array ? bytes : new Uint8Array(bytes);
          let head = Atomics.load(this.ctrl, 0);
          let tail = Atomics.load(this.ctrl, 1);
          for (let i = 0; i < src.length; i += 1) {
            const next = (tail + 1) % this.capacity;
            if (next === head) break;
            this.data[tail] = src[i];
            tail = next;
          }
          Atomics.store(this.ctrl, 1, tail);
          Atomics.notify(this.ctrl, 1);
        }
      }

      gridEl.addEventListener("click", () => { gridEl.focus(); warmupClipboard(); });
      gridEl.addEventListener("keydown", (ev) => {
        const keys = translateKey(ev);
        if (!keys) return;
        ev.preventDefault();
        sendInput(keys);
      });

      function startSession() {
        if (!window.crossOriginIsolated) {
          setStatus("Serve with COOP/COEP so SharedArrayBuffer works", true);
          return;
        }
        warmupClipboard();
        stopSession();
        ring = new SharedInputWriter();
        reqId = 0;
        primeSent = false;
        worker = new Worker(`./nvim-worker.js?${WORKER_VERSION}`, { type: "module" });
        worker.onmessage = handleWorkerMessage;
        worker.postMessage({ type: "start", inputBuffer: ring.buffer, cols, rows });
        setStatus("Starting Neovim...");
        // Fallback: ensure primeRpc runs even if status message is missed.
        setTimeout(() => { if (!primeSent) primeRpc(); }, 500);
      }

      function stopSession() { if (worker) { worker.terminate(); worker = null; } }

      function primeRpc() {
        sendRpc("nvim_ui_attach", [cols, rows, { rgb: true, ext_linegrid: true, ext_hlstate: true }]);
        sendRpc("nvim_ui_try_resize", [cols, rows]);
        sendRpc("nvim_command", ["set noswapfile"]);
        sendRpc("nvim_command", ["set number"]);
        sendRpc("nvim_command", ["set fillchars=eob:~"]);
        const clipboardLua = `
          local function setup_clipboard()
            local ui_chan = (vim.api.nvim_get_api_info() or {})[1]
            if not ui_chan then return end
            local function copy(lines, regtype)
              vim.rpcnotify(ui_chan, 'wasm-clipboard-copy', lines, regtype)
            end
            local function paste()
              local ok, res = pcall(vim.rpcrequest, ui_chan, 'wasm-clipboard-paste')
              if not ok then return {}, 'v' end
              local lines = res and res[1] or {}
              local regtype = res and res[2] or 'v'
              return lines, regtype
            end
            vim.g.clipboard = {
              name = 'wasm',
              copy = { ['+'] = copy, ['*'] = copy },
              paste = { ['+'] = paste, ['*'] = paste },
            }
            vim.cmd('set clipboard=unnamedplus')
          end
          setup_clipboard()
        `;
        sendRpc("nvim_exec_lua", [clipboardLua, []]);
        // Force demo buffer content after attach so the grid isn't blank.
        const lua = `
          local lines = ...
          vim.cmd('enew')
          local buf = vim.api.nvim_get_current_buf()
          vim.api.nvim_buf_set_lines(buf, 0, -1, false, lines)
          vim.bo[buf].buftype = ''
          vim.bo[buf].modifiable = true
          vim.bo[buf].modified = true
          vim.api.nvim_buf_set_name(buf, 'demo.txt')
          vim.cmd('redraw!')
        `;
        sendRpc("nvim_exec_lua", [lua, [
          "Neovim WASM demo",
          "",
          "- click the grid and type",
          "- press i for insert mode",
          "- :q to quit",
          "",
          "Happy editing!",
        ]]);
        sendRpc("nvim_command", ["redraw!"]);
        primeSent = true;
      }

      function sendRpc(method, params = []) {
        if (!ring) return;
        const msg = encode([0, reqId++, method, params]);
        ring.push(msg);
      }

      function sendRpcResponse(msgid, error, result) {
        if (!ring) return;
        const msg = encode([1, msgid, error, result]);
        ring.push(msg);
      }

      function sendInput(keys) { sendRpc("nvim_input", [keys]); }

      function handleWorkerMessage(event) {
        const { type } = event.data || {};
        if (type === "draw-text") {
          const cells = event.data.cells && event.data.cells.length ? event.data.cells : linesToCells(event.data.lines);
          renderGrid(cells, event.data.cursor, event.data.cursorHlId, event.data.mode, event.data.hls);
        } else if (type === "exit") {
          setStatus(`nvim exited (${event.data.code})`, event.data.code !== 0);
        } else if (type === "clipboard-copy") {
          const text = (event.data.lines || []).join("\n");
          if (!navigator.clipboard?.writeText) return;
          lastClipboard = text;
          navigator.clipboard.writeText(text).catch(() => { lastClipboard = text; });
        } else if (type === "clipboard-paste") {
          const req = event.data.requestId;
          doClipboardPaste(req);
        }
      }

      function renderGrid(cells = [], cursor = null, cursorHlId = 0, mode = "-", hls = {}) {
        const rows = Array.isArray(cells) && cells.length ? cells : [];
        const cur = cursor || { row: 0, col: 0 };
        const row = Math.max(0, Math.min(cur.row || 0, rows.length ? rows.length - 1 : 0));
        const col = Math.max(0, cur.col || 0);
        const hlMap = hls || {};

        let html = "";
        for (let r = 0; r < rows.length; r += 1) {
          const rowCells = Array.isArray(rows[r]) ? rows[r] : [];
          const lineLen = rowCells.length;
          for (let c = 0; c < lineLen; c += 1) {
            const cell = rowCells[c] || {};
            const ch = escapeChar(cell.ch || " ");
            const attr = r === row && c === col
              ? getHl(hlMap, cursorHlId, true)
              : getHl(hlMap, cell.hl, false);
            const style = styleFromHl(attr);
            if (r === row && c === col) {
              html += style ? `<span class="cursor" style="${style}">${ch}</span>` : `<span class="cursor">${ch}</span>`;
            } else if (style) {
              html += `<span style="${style}">${ch}</span>`;
            } else {
              html += ch;
            }
          }
          if (r === row && col >= lineLen) {
            html += " ".repeat(col - lineLen);
            const attr = getHl(hlMap, cursorHlId, true);
            const style = styleFromHl(attr);
            html += style ? `<span class="cursor" style="${style}"> </span>` : `<span class="cursor"> </span>`;
          }
          if (r < rows.length - 1) html += "\n";
        }

        gridEl.innerHTML = html || " ";
        modeEl.textContent = `mode: ${mode || "-"}`;
      }

      function styleFromHl(attr) {
        if (!attr) return "";
        let fg = attr.foreground;
        let bg = attr.background;
        if (attr.reverse) {
          const tmpBg = bg || fallbackBg;
          const tmpFg = fg || fallbackFg;
          fg = tmpBg;
          bg = tmpFg;
        } else {
          if (!fg) fg = fallbackFg;
          if (!bg) bg = null;
        }
        const parts = [];
        if (fg) parts.push(`color:${fg}`);
        if (bg) parts.push(`background:${bg}`);
        return parts.join(";");
      }

      function getHl(map, id, isCursor) {
        const key = id != null && map[id] !== undefined ? id : String(id);
        const hl = (key != null && map[key] !== undefined ? map[key] : null) || map[0] || map["0"] || null;
        if (!hl) {
          if (isCursor) return { foreground: fallbackFg, background: fallbackBg, reverse: true };
          return null;
        }
        const reverse = Boolean(hl.reverse) || (isCursor && Number(id) === 0);
        return { foreground: hl.foreground, background: hl.background, reverse };
      }

      function escapeChar(ch) {
        switch (ch) {
          case "&": return "&amp;";
          case "<": return "&lt;";
          case ">": return "&gt;";
          case '"': return "&quot;";
          default: return ch || " ";
        }
      }

      function linesToCells(lines = []) {
        const data = lines && lines.length ? lines : [""];
        return data.map((line) => Array.from(line || "").map((ch) => ({ ch, hl: 0 })));
      }

      function warmupClipboard() {
        if (!navigator.clipboard?.readText) return;
        navigator.clipboard.readText().then((txt) => { if (txt) lastClipboard = txt; }).catch(() => {});
      }

      function doClipboardPaste(req) {
        const fallback = () => {
          if (lastClipboard !== "") {
            sendRpcResponse(req, null, [lastClipboard.split(/\r?\n/), "v"]);
            return true;
          }
          const manual = window.prompt("Paste text");
          if (manual !== null) {
            lastClipboard = manual;
            sendRpcResponse(req, null, [manual.split(/\r?\n/), "v"]);
            return true;
          }
          sendRpcResponse(req, null, [[""], "v"]);
          return true;
        };

        if (!navigator.clipboard?.readText) {
          fallback();
          return;
        }
        navigator.clipboard.readText()
          .then((text) => {
            const effective = text || lastClipboard;
            if (!effective) { fallback(); return; }
            lastClipboard = effective;
            const lines = effective.split(/\r?\n/);
            sendRpcResponse(req, null, [lines, "v"]);
          })
          .catch((err) => {
            console.warn("clipboard read failed", err);
            fallback();
          });
      }

      function setStatus(text, error = false) { statusEl.textContent = text; statusEl.style.color = error ? "#ff9ea2" : "#e8edf5"; }

      function translateKey(ev) {
        const key = ev.key; const isCtrl = ev.ctrlKey || ev.metaKey; const isAlt = ev.altKey;
        switch (key) {
          case "Backspace": return "<BS>";
          case "Enter": return "<CR>";
          case "Escape": return "<Esc>";
          case "Tab": return "<Tab>";
          case "ArrowUp": return "<Up>";
          case "ArrowDown": return "<Down>";
          case "ArrowLeft": return "<Left>";
          case "ArrowRight": return "<Right>";
          case "Delete": return "<Del>";
          case "Home": return "<Home>";
          case "End": return "<End>";
          case "PageUp": return "<PageUp>";
          case "PageDown": return "<PageDown>";
          case "Insert": return "<Insert>";
          default: break;
        }
        if (key.length === 1) {
          const char = ev.shiftKey ? key : key.toLowerCase();
          if (!isCtrl && !isAlt) return char;
          let mod = "";
          if (isCtrl) mod += "C-";
          if (isAlt) mod += "A-";
          return `<${mod}${char}>`;
        }
        return null;
      }

      startSession();
    </script>
  </body>
</html>
