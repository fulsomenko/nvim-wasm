diff --git a/CMakeLists.txt b/CMakeLists.txt
index 73d5aff..9df0d03 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -185,6 +185,23 @@ set(uv_sources
     src/uv-data-getter-setters.c
     src/version.c)
 
+if(CMAKE_SYSTEM_NAME STREQUAL "WASI"
+   OR CMAKE_C_COMPILER_TARGET MATCHES "wasm32.*wasi"
+   OR CMAKE_C_COMPILER MATCHES "wasi")
+  list(APPEND uv_defines __wasi__ _WASI_EMULATED_SIGNAL)
+  add_library(uv_a STATIC src/wasi/stub.c)
+  target_compile_definitions(uv_a PRIVATE ${uv_defines})
+  target_compile_options(uv_a PRIVATE ${uv_cflags})
+  target_include_directories(uv_a
+    PUBLIC
+      $<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}/include>
+      $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>)
+  set_target_properties(uv_a PROPERTIES OUTPUT_NAME "uv")
+  install(TARGETS uv_a ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR})
+  install(DIRECTORY include/ DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/)
+  return()
+endif()
+
 if(WIN32)
   list(APPEND uv_defines WIN32_LEAN_AND_MEAN _WIN32_WINNT=0x0A00 _CRT_DECLARE_NONSTDC_NAMES=0)
   list(APPEND uv_libraries
diff --git a/include/uv/unix.h b/include/uv/unix.h
index 7c97202..0e007dd 100644
--- a/include/uv/unix.h
+++ b/include/uv/unix.h
@@ -27,18 +27,27 @@
 #include <fcntl.h>
 #include <dirent.h>
 
+#if defined(__wasi__)
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <netinet/tcp.h>
+#include <arpa/inet.h>
+#include <sys/param.h>
+#else
 #include <sys/socket.h>
 #include <netinet/in.h>
 #include <netinet/tcp.h>
 #include <arpa/inet.h>
 #include <netdb.h>  /* MAXHOSTNAMELEN on Solaris */
-
 #include <termios.h>
 #include <pwd.h>
+# if !defined(__MVS__)
+#include <sys/param.h> /* MAXHOSTNAMELEN on Linux and the BSDs */
+# endif
+#endif
 
 #if !defined(__MVS__)
 #include <semaphore.h>
-#include <sys/param.h> /* MAXHOSTNAMELEN on Linux and the BSDs */
 #endif
 #include <pthread.h>
 #include <signal.h>
@@ -383,6 +392,11 @@ typedef struct {
   struct termios orig_termios;                                                \
   int mode;
 
+#if defined(__wasi__)
+#undef UV_TTY_PRIVATE_FIELDS
+#define UV_TTY_PRIVATE_FIELDS int mode;
+#endif
+
 #define UV_SIGNAL_PRIVATE_FIELDS                                              \
   /* RB_ENTRY(uv_signal_s) tree_entry; */                                     \
   struct {                                                                    \
diff --git a/src/wasi/stub.c b/src/wasi/stub.c
new file mode 100644
index 0000000..960f575
--- /dev/null
+++ b/src/wasi/stub.c
@@ -0,0 +1,1910 @@
+#include "uv.h"
+#include <string.h>
+#include <stdlib.h>
+#include <time.h>
+
+#define UV__UNUSED(x) ((void)(x))
+
+unsigned int uv_version(void) {
+  return UV_VERSION_HEX;
+}
+
+const char* uv_version_string(void) {
+  return "wasi-stub";
+}
+
+void uv_library_shutdown(void) {
+  return;
+}
+
+int uv_replace_allocator(uv_malloc_func malloc_func, uv_realloc_func realloc_func, uv_calloc_func calloc_func, uv_free_func free_func) {
+  UV__UNUSED(malloc_func); UV__UNUSED(realloc_func); UV__UNUSED(calloc_func); UV__UNUSED(free_func); return 0;
+}
+
+uv_loop_t* uv_default_loop(void) {
+  static uv_loop_t default_loop; return &default_loop;
+}
+
+int uv_loop_init(uv_loop_t* loop) {
+  if (loop) memset(loop, 0, sizeof(*loop)); return 0;
+}
+
+int uv_loop_close(uv_loop_t* loop) {
+  return 0;
+}
+
+uv_loop_t* uv_loop_new(void) {
+  uv_loop_t* loop = (uv_loop_t*)malloc(sizeof(uv_loop_t)); if (loop) memset(loop, 0, sizeof(*loop)); return loop;
+}
+
+void uv_loop_delete(uv_loop_t* arg0) {
+  free(arg0);
+}
+
+size_t uv_loop_size(void) {
+  return sizeof(uv_loop_t);
+}
+
+int uv_loop_alive(const uv_loop_t* loop) {
+  UV__UNUSED(loop); return 0;
+}
+
+int uv_loop_configure(uv_loop_t* loop, uv_loop_option option, ...) {
+  UV__UNUSED(loop); UV__UNUSED(option); return UV_ENOSYS;
+}
+
+int uv_loop_fork(uv_loop_t* loop) {
+  UV__UNUSED(loop);
+  return UV_ENOSYS;
+}
+
+int uv_run(uv_loop_t* arg0, uv_run_mode mode) {
+  UV__UNUSED(arg0); UV__UNUSED(mode); return 0;
+}
+
+void uv_stop(uv_loop_t* arg0) {
+  if (arg0) arg0->stop_flag = 1;
+}
+
+void uv_ref(uv_handle_t* arg0) {
+  UV__UNUSED(arg0);
+}
+
+void uv_unref(uv_handle_t* arg0) {
+  UV__UNUSED(arg0);
+}
+
+int uv_has_ref(const uv_handle_t* arg0) {
+  UV__UNUSED(arg0); return 0;
+}
+
+void uv_update_time(uv_loop_t* arg0) {
+  if (arg0) arg0->time = uv_now(arg0);
+}
+
+uint64_t uv_now(const uv_loop_t* arg0) {
+  if (!arg0) return 0; return arg0->time;
+}
+
+int uv_backend_fd(const uv_loop_t* arg0) {
+  UV__UNUSED(arg0); return -1;
+}
+
+int uv_backend_timeout(const uv_loop_t* arg0) {
+  UV__UNUSED(arg0); return 0;
+}
+
+int uv_translate_sys_error(int sys_errno) {
+  return sys_errno;
+}
+
+const char* uv_strerror(int err) {
+  UV__UNUSED(err);
+  return NULL;
+}
+
+char* uv_strerror_r(int err, char* buf, size_t buflen) {
+  UV__UNUSED(err);
+  UV__UNUSED(buf);
+  UV__UNUSED(buflen);
+  return NULL;
+}
+
+const char* uv_err_name(int err) {
+  UV__UNUSED(err);
+  return NULL;
+}
+
+char* uv_err_name_r(int err, char* buf, size_t buflen) {
+  UV__UNUSED(err);
+  UV__UNUSED(buf);
+  UV__UNUSED(buflen);
+  return NULL;
+}
+
+int uv_shutdown(uv_shutdown_t* req, uv_stream_t* handle, uv_shutdown_cb cb) {
+  UV__UNUSED(req);
+  UV__UNUSED(handle);
+  UV__UNUSED(cb);
+  return UV_ENOSYS;
+}
+
+size_t uv_handle_size(uv_handle_type type) {
+  switch (type) {
+  #define XX(uc, lc) case UV_##uc: return sizeof(uv_##lc##_t);
+      UV_HANDLE_TYPE_MAP(XX)
+  #undef XX
+      default: return 0;
+    }
+}
+
+uv_handle_type uv_handle_get_type(const uv_handle_t* handle) {
+  UV__UNUSED(handle);
+  return 0;
+}
+
+const char* uv_handle_type_name(uv_handle_type type) {
+  UV__UNUSED(type);
+  return NULL;
+}
+
+void* uv_handle_get_data(const uv_handle_t* handle) {
+  UV__UNUSED(handle);
+  return NULL;
+}
+
+uv_loop_t* uv_handle_get_loop(const uv_handle_t* handle) {
+  UV__UNUSED(handle);
+  return NULL;
+}
+
+void uv_handle_set_data(uv_handle_t* handle, void* data) {
+  UV__UNUSED(handle);
+  UV__UNUSED(data);
+}
+
+size_t uv_req_size(uv_req_type type) {
+  switch (type) {
+  #define XX(uc, lc) case UV_##uc: return sizeof(uv_##lc##_t);
+      UV_REQ_TYPE_MAP(XX)
+  #undef XX
+      default: return 0;
+    }
+}
+
+void* uv_req_get_data(const uv_req_t* req) {
+  UV__UNUSED(req);
+  return NULL;
+}
+
+void uv_req_set_data(uv_req_t* req, void* data) {
+  UV__UNUSED(req);
+  UV__UNUSED(data);
+}
+
+uv_req_type uv_req_get_type(const uv_req_t* req) {
+  UV__UNUSED(req);
+  return 0;
+}
+
+const char* uv_req_type_name(uv_req_type type) {
+  UV__UNUSED(type);
+  return NULL;
+}
+
+int uv_is_active(const uv_handle_t* handle) {
+  UV__UNUSED(handle);
+  return UV_ENOSYS;
+}
+
+void uv_walk(uv_loop_t* loop, uv_walk_cb walk_cb, void* arg) {
+  UV__UNUSED(loop); UV__UNUSED(walk_cb); UV__UNUSED(arg);
+}
+
+void uv_print_all_handles(uv_loop_t* loop, FILE* stream) {
+  UV__UNUSED(loop);
+  UV__UNUSED(stream);
+}
+
+void uv_print_active_handles(uv_loop_t* loop, FILE* stream) {
+  UV__UNUSED(loop);
+  UV__UNUSED(stream);
+}
+
+void uv_close(uv_handle_t* handle, uv_close_cb close_cb) {
+  UV__UNUSED(handle);
+  UV__UNUSED(close_cb);
+}
+
+int uv_send_buffer_size(uv_handle_t* handle, int* value) {
+  UV__UNUSED(handle);
+  UV__UNUSED(value);
+  return UV_ENOSYS;
+}
+
+int uv_recv_buffer_size(uv_handle_t* handle, int* value) {
+  UV__UNUSED(handle);
+  UV__UNUSED(value);
+  return UV_ENOSYS;
+}
+
+int uv_fileno(const uv_handle_t* handle, uv_os_fd_t* fd) {
+  UV__UNUSED(handle);
+  UV__UNUSED(fd);
+  return UV_ENOSYS;
+}
+
+uv_buf_t uv_buf_init(char* base, unsigned int len) {
+  uv_buf_t buf; buf.base = base; buf.len = len; return buf;
+}
+
+int uv_pipe(uv_file fds[2], int read_flags, int write_flags) {
+  UV__UNUSED(fds);
+  UV__UNUSED(read_flags);
+  UV__UNUSED(write_flags);
+  return UV_ENOSYS;
+}
+
+int uv_socketpair(int type, int protocol, uv_os_sock_t socket_vector[2], int flags0, int flags1) {
+  UV__UNUSED(type);
+  UV__UNUSED(protocol);
+  UV__UNUSED(socket_vector);
+  UV__UNUSED(flags0);
+  UV__UNUSED(flags1);
+  return UV_ENOSYS;
+}
+
+size_t uv_stream_get_write_queue_size(const uv_stream_t* stream) {
+  UV__UNUSED(stream);
+  return 0;
+}
+
+int uv_listen(uv_stream_t* stream, int backlog, uv_connection_cb cb) {
+  UV__UNUSED(stream);
+  UV__UNUSED(backlog);
+  UV__UNUSED(cb);
+  return UV_ENOSYS;
+}
+
+int uv_accept(uv_stream_t* server, uv_stream_t* client) {
+  UV__UNUSED(server);
+  UV__UNUSED(client);
+  return UV_ENOSYS;
+}
+
+int uv_read_start(uv_stream_t* arg0, uv_alloc_cb alloc_cb, uv_read_cb read_cb) {
+  UV__UNUSED(arg0);
+  UV__UNUSED(alloc_cb);
+  UV__UNUSED(read_cb);
+  return UV_ENOSYS;
+}
+
+int uv_read_stop(uv_stream_t* arg0) {
+  UV__UNUSED(arg0);
+  return UV_ENOSYS;
+}
+
+int uv_write(uv_write_t* req, uv_stream_t* handle, const uv_buf_t bufs[], unsigned int nbufs, uv_write_cb cb) {
+  UV__UNUSED(req);
+  UV__UNUSED(handle);
+  UV__UNUSED(bufs);
+  UV__UNUSED(nbufs);
+  UV__UNUSED(cb);
+  return UV_ENOSYS;
+}
+
+int uv_write2(uv_write_t* req, uv_stream_t* handle, const uv_buf_t bufs[], unsigned int nbufs, uv_stream_t* send_handle, uv_write_cb cb) {
+  UV__UNUSED(req);
+  UV__UNUSED(handle);
+  UV__UNUSED(bufs);
+  UV__UNUSED(nbufs);
+  UV__UNUSED(send_handle);
+  UV__UNUSED(cb);
+  return UV_ENOSYS;
+}
+
+int uv_try_write(uv_stream_t* handle, const uv_buf_t bufs[], unsigned int nbufs) {
+  UV__UNUSED(handle);
+  UV__UNUSED(bufs);
+  UV__UNUSED(nbufs);
+  return UV_ENOSYS;
+}
+
+int uv_try_write2(uv_stream_t* handle, const uv_buf_t bufs[], unsigned int nbufs, uv_stream_t* send_handle) {
+  UV__UNUSED(handle);
+  UV__UNUSED(bufs);
+  UV__UNUSED(nbufs);
+  UV__UNUSED(send_handle);
+  return UV_ENOSYS;
+}
+
+int uv_is_readable(const uv_stream_t* handle) {
+  UV__UNUSED(handle);
+  return UV_ENOSYS;
+}
+
+int uv_is_writable(const uv_stream_t* handle) {
+  UV__UNUSED(handle);
+  return UV_ENOSYS;
+}
+
+int uv_stream_set_blocking(uv_stream_t* handle, int blocking) {
+  UV__UNUSED(handle);
+  UV__UNUSED(blocking);
+  return UV_ENOSYS;
+}
+
+int uv_is_closing(const uv_handle_t* handle) {
+  UV__UNUSED(handle);
+  return UV_ENOSYS;
+}
+
+int uv_tcp_init(uv_loop_t* arg0, uv_tcp_t* handle) {
+  UV__UNUSED(arg0);
+  UV__UNUSED(handle);
+  return UV_ENOSYS;
+}
+
+int uv_tcp_init_ex(uv_loop_t* arg0, uv_tcp_t* handle, unsigned int flags) {
+  UV__UNUSED(arg0);
+  UV__UNUSED(handle);
+  UV__UNUSED(flags);
+  return UV_ENOSYS;
+}
+
+int uv_tcp_open(uv_tcp_t* handle, uv_os_sock_t sock) {
+  UV__UNUSED(handle);
+  UV__UNUSED(sock);
+  return UV_ENOSYS;
+}
+
+int uv_tcp_nodelay(uv_tcp_t* handle, int enable) {
+  UV__UNUSED(handle);
+  UV__UNUSED(enable);
+  return UV_ENOSYS;
+}
+
+int uv_tcp_keepalive(uv_tcp_t* handle, int enable, unsigned int delay) {
+  UV__UNUSED(handle);
+  UV__UNUSED(enable);
+  UV__UNUSED(delay);
+  return UV_ENOSYS;
+}
+
+int uv_tcp_simultaneous_accepts(uv_tcp_t* handle, int enable) {
+  UV__UNUSED(handle);
+  UV__UNUSED(enable);
+  return UV_ENOSYS;
+}
+
+int uv_tcp_bind(uv_tcp_t* handle, const struct sockaddr* addr, unsigned int flags) {
+  UV__UNUSED(handle);
+  UV__UNUSED(addr);
+  UV__UNUSED(flags);
+  return UV_ENOSYS;
+}
+
+int uv_tcp_getsockname(const uv_tcp_t* handle, struct sockaddr* name, int* namelen) {
+  UV__UNUSED(handle);
+  UV__UNUSED(name);
+  UV__UNUSED(namelen);
+  return UV_ENOSYS;
+}
+
+int uv_tcp_getpeername(const uv_tcp_t* handle, struct sockaddr* name, int* namelen) {
+  UV__UNUSED(handle);
+  UV__UNUSED(name);
+  UV__UNUSED(namelen);
+  return UV_ENOSYS;
+}
+
+int uv_tcp_close_reset(uv_tcp_t* handle, uv_close_cb close_cb) {
+  UV__UNUSED(handle);
+  UV__UNUSED(close_cb);
+  return UV_ENOSYS;
+}
+
+int uv_tcp_connect(uv_connect_t* req, uv_tcp_t* handle, const struct sockaddr* addr, uv_connect_cb cb) {
+  UV__UNUSED(req);
+  UV__UNUSED(handle);
+  UV__UNUSED(addr);
+  UV__UNUSED(cb);
+  return UV_ENOSYS;
+}
+
+int uv_udp_init(uv_loop_t* arg0, uv_udp_t* handle) {
+  UV__UNUSED(arg0);
+  UV__UNUSED(handle);
+  return UV_ENOSYS;
+}
+
+int uv_udp_init_ex(uv_loop_t* arg0, uv_udp_t* handle, unsigned int flags) {
+  UV__UNUSED(arg0);
+  UV__UNUSED(handle);
+  UV__UNUSED(flags);
+  return UV_ENOSYS;
+}
+
+int uv_udp_open(uv_udp_t* handle, uv_os_sock_t sock) {
+  UV__UNUSED(handle);
+  UV__UNUSED(sock);
+  return UV_ENOSYS;
+}
+
+int uv_udp_bind(uv_udp_t* handle, const struct sockaddr* addr, unsigned int flags) {
+  UV__UNUSED(handle);
+  UV__UNUSED(addr);
+  UV__UNUSED(flags);
+  return UV_ENOSYS;
+}
+
+int uv_udp_connect(uv_udp_t* handle, const struct sockaddr* addr) {
+  UV__UNUSED(handle);
+  UV__UNUSED(addr);
+  return UV_ENOSYS;
+}
+
+int uv_udp_getpeername(const uv_udp_t* handle, struct sockaddr* name, int* namelen) {
+  UV__UNUSED(handle);
+  UV__UNUSED(name);
+  UV__UNUSED(namelen);
+  return UV_ENOSYS;
+}
+
+int uv_udp_getsockname(const uv_udp_t* handle, struct sockaddr* name, int* namelen) {
+  UV__UNUSED(handle);
+  UV__UNUSED(name);
+  UV__UNUSED(namelen);
+  return UV_ENOSYS;
+}
+
+int uv_udp_set_membership(uv_udp_t* handle, const char* multicast_addr, const char* interface_addr, uv_membership membership) {
+  UV__UNUSED(handle);
+  UV__UNUSED(multicast_addr);
+  UV__UNUSED(interface_addr);
+  UV__UNUSED(membership);
+  return UV_ENOSYS;
+}
+
+int uv_udp_set_source_membership(uv_udp_t* handle, const char* multicast_addr, const char* interface_addr, const char* source_addr, uv_membership membership) {
+  UV__UNUSED(handle);
+  UV__UNUSED(multicast_addr);
+  UV__UNUSED(interface_addr);
+  UV__UNUSED(source_addr);
+  UV__UNUSED(membership);
+  return UV_ENOSYS;
+}
+
+int uv_udp_set_multicast_loop(uv_udp_t* handle, int on) {
+  UV__UNUSED(handle);
+  UV__UNUSED(on);
+  return UV_ENOSYS;
+}
+
+int uv_udp_set_multicast_ttl(uv_udp_t* handle, int ttl) {
+  UV__UNUSED(handle);
+  UV__UNUSED(ttl);
+  return UV_ENOSYS;
+}
+
+int uv_udp_set_multicast_interface(uv_udp_t* handle, const char* interface_addr) {
+  UV__UNUSED(handle);
+  UV__UNUSED(interface_addr);
+  return UV_ENOSYS;
+}
+
+int uv_udp_set_broadcast(uv_udp_t* handle, int on) {
+  UV__UNUSED(handle);
+  UV__UNUSED(on);
+  return UV_ENOSYS;
+}
+
+int uv_udp_set_ttl(uv_udp_t* handle, int ttl) {
+  UV__UNUSED(handle);
+  UV__UNUSED(ttl);
+  return UV_ENOSYS;
+}
+
+int uv_udp_send(uv_udp_send_t* req, uv_udp_t* handle, const uv_buf_t bufs[], unsigned int nbufs, const struct sockaddr* addr, uv_udp_send_cb send_cb) {
+  UV__UNUSED(req);
+  UV__UNUSED(handle);
+  UV__UNUSED(bufs);
+  UV__UNUSED(nbufs);
+  UV__UNUSED(addr);
+  UV__UNUSED(send_cb);
+  return UV_ENOSYS;
+}
+
+int uv_udp_try_send(uv_udp_t* handle, const uv_buf_t bufs[], unsigned int nbufs, const struct sockaddr* addr) {
+  UV__UNUSED(handle);
+  UV__UNUSED(bufs);
+  UV__UNUSED(nbufs);
+  UV__UNUSED(addr);
+  return UV_ENOSYS;
+}
+
+int uv_udp_try_send2(uv_udp_t* handle, unsigned int count, uv_buf_t* bufs[/*count*/], unsigned int nbufs[/*count*/], struct sockaddr* addrs[/*count*/], unsigned int flags) {
+  UV__UNUSED(handle);
+  UV__UNUSED(count);
+  UV__UNUSED(bufs);
+  UV__UNUSED(nbufs);
+  UV__UNUSED(addrs);
+  UV__UNUSED(flags);
+  return UV_ENOSYS;
+}
+
+int uv_udp_recv_start(uv_udp_t* handle, uv_alloc_cb alloc_cb, uv_udp_recv_cb recv_cb) {
+  UV__UNUSED(handle);
+  UV__UNUSED(alloc_cb);
+  UV__UNUSED(recv_cb);
+  return UV_ENOSYS;
+}
+
+int uv_udp_using_recvmmsg(const uv_udp_t* handle) {
+  UV__UNUSED(handle);
+  return UV_ENOSYS;
+}
+
+int uv_udp_recv_stop(uv_udp_t* handle) {
+  UV__UNUSED(handle);
+  return UV_ENOSYS;
+}
+
+size_t uv_udp_get_send_queue_size(const uv_udp_t* handle) {
+  UV__UNUSED(handle);
+  return 0;
+}
+
+size_t uv_udp_get_send_queue_count(const uv_udp_t* handle) {
+  UV__UNUSED(handle);
+  return 0;
+}
+
+int uv_tty_init(uv_loop_t* arg0, uv_tty_t* arg1, uv_file fd, int readable) {
+  UV__UNUSED(arg0);
+  UV__UNUSED(arg1);
+  UV__UNUSED(fd);
+  UV__UNUSED(readable);
+  return UV_ENOSYS;
+}
+
+int uv_tty_set_mode(uv_tty_t* arg0, uv_tty_mode_t mode) {
+  UV__UNUSED(arg0);
+  UV__UNUSED(mode);
+  return UV_ENOSYS;
+}
+
+int uv_tty_reset_mode(void) {
+  return UV_ENOSYS;
+}
+
+int uv_tty_get_winsize(uv_tty_t* arg0, int* width, int* height) {
+  UV__UNUSED(arg0);
+  UV__UNUSED(width);
+  UV__UNUSED(height);
+  return UV_ENOSYS;
+}
+
+void uv_tty_set_vterm_state(uv_tty_vtermstate_t state) {
+  UV__UNUSED(state);
+}
+
+int uv_tty_get_vterm_state(uv_tty_vtermstate_t* state) {
+  UV__UNUSED(state);
+  return UV_ENOSYS;
+}
+
+uv_handle_type uv_guess_handle(uv_file file) {
+  UV__UNUSED(file);
+  return 0;
+}
+
+int uv_pipe_init(uv_loop_t* arg0, uv_pipe_t* handle, int ipc) {
+  UV__UNUSED(arg0);
+  UV__UNUSED(handle);
+  UV__UNUSED(ipc);
+  return UV_ENOSYS;
+}
+
+int uv_pipe_open(uv_pipe_t* arg0, uv_file file) {
+  UV__UNUSED(arg0);
+  UV__UNUSED(file);
+  return UV_ENOSYS;
+}
+
+int uv_pipe_bind(uv_pipe_t* handle, const char* name) {
+  UV__UNUSED(handle);
+  UV__UNUSED(name);
+  return UV_ENOSYS;
+}
+
+int uv_pipe_bind2(uv_pipe_t* handle, const char* name, size_t namelen, unsigned int flags) {
+  UV__UNUSED(handle);
+  UV__UNUSED(name);
+  UV__UNUSED(namelen);
+  UV__UNUSED(flags);
+  return UV_ENOSYS;
+}
+
+void uv_pipe_connect(uv_connect_t* req, uv_pipe_t* handle, const char* name, uv_connect_cb cb) {
+  UV__UNUSED(req);
+  UV__UNUSED(handle);
+  UV__UNUSED(name);
+  UV__UNUSED(cb);
+}
+
+int uv_pipe_connect2(uv_connect_t* req, uv_pipe_t* handle, const char* name, size_t namelen, unsigned int flags, uv_connect_cb cb) {
+  UV__UNUSED(req);
+  UV__UNUSED(handle);
+  UV__UNUSED(name);
+  UV__UNUSED(namelen);
+  UV__UNUSED(flags);
+  UV__UNUSED(cb);
+  return UV_ENOSYS;
+}
+
+int uv_pipe_getsockname(const uv_pipe_t* handle, char* buffer, size_t* size) {
+  UV__UNUSED(handle);
+  UV__UNUSED(buffer);
+  UV__UNUSED(size);
+  return UV_ENOSYS;
+}
+
+int uv_pipe_getpeername(const uv_pipe_t* handle, char* buffer, size_t* size) {
+  UV__UNUSED(handle);
+  UV__UNUSED(buffer);
+  UV__UNUSED(size);
+  return UV_ENOSYS;
+}
+
+void uv_pipe_pending_instances(uv_pipe_t* handle, int count) {
+  UV__UNUSED(handle);
+  UV__UNUSED(count);
+}
+
+int uv_pipe_pending_count(uv_pipe_t* handle) {
+  UV__UNUSED(handle);
+  return UV_ENOSYS;
+}
+
+uv_handle_type uv_pipe_pending_type(uv_pipe_t* handle) {
+  UV__UNUSED(handle);
+  return 0;
+}
+
+int uv_pipe_chmod(uv_pipe_t* handle, int flags) {
+  UV__UNUSED(handle);
+  UV__UNUSED(flags);
+  return UV_ENOSYS;
+}
+
+int uv_poll_init(uv_loop_t* loop, uv_poll_t* handle, int fd) {
+  UV__UNUSED(loop);
+  UV__UNUSED(handle);
+  UV__UNUSED(fd);
+  return UV_ENOSYS;
+}
+
+int uv_poll_init_socket(uv_loop_t* loop, uv_poll_t* handle, uv_os_sock_t socket) {
+  UV__UNUSED(loop);
+  UV__UNUSED(handle);
+  UV__UNUSED(socket);
+  return UV_ENOSYS;
+}
+
+int uv_poll_start(uv_poll_t* handle, int events, uv_poll_cb cb) {
+  UV__UNUSED(handle);
+  UV__UNUSED(events);
+  UV__UNUSED(cb);
+  return UV_ENOSYS;
+}
+
+int uv_poll_stop(uv_poll_t* handle) {
+  UV__UNUSED(handle);
+  return UV_ENOSYS;
+}
+
+int uv_prepare_init(uv_loop_t* arg0, uv_prepare_t* prepare) {
+  UV__UNUSED(arg0);
+  UV__UNUSED(prepare);
+  return UV_ENOSYS;
+}
+
+int uv_prepare_start(uv_prepare_t* prepare, uv_prepare_cb cb) {
+  UV__UNUSED(prepare);
+  UV__UNUSED(cb);
+  return UV_ENOSYS;
+}
+
+int uv_prepare_stop(uv_prepare_t* prepare) {
+  UV__UNUSED(prepare);
+  return UV_ENOSYS;
+}
+
+int uv_check_init(uv_loop_t* arg0, uv_check_t* check) {
+  UV__UNUSED(arg0);
+  UV__UNUSED(check);
+  return UV_ENOSYS;
+}
+
+int uv_check_start(uv_check_t* check, uv_check_cb cb) {
+  UV__UNUSED(check);
+  UV__UNUSED(cb);
+  return UV_ENOSYS;
+}
+
+int uv_check_stop(uv_check_t* check) {
+  UV__UNUSED(check);
+  return UV_ENOSYS;
+}
+
+int uv_idle_init(uv_loop_t* arg0, uv_idle_t* idle) {
+  UV__UNUSED(arg0);
+  UV__UNUSED(idle);
+  return UV_ENOSYS;
+}
+
+int uv_idle_start(uv_idle_t* idle, uv_idle_cb cb) {
+  UV__UNUSED(idle);
+  UV__UNUSED(cb);
+  return UV_ENOSYS;
+}
+
+int uv_idle_stop(uv_idle_t* idle) {
+  UV__UNUSED(idle);
+  return UV_ENOSYS;
+}
+
+int uv_async_init(uv_loop_t* arg0, uv_async_t* async, uv_async_cb async_cb) {
+  UV__UNUSED(arg0);
+  UV__UNUSED(async);
+  UV__UNUSED(async_cb);
+  return UV_ENOSYS;
+}
+
+int uv_async_send(uv_async_t* async) {
+  UV__UNUSED(async);
+  return UV_ENOSYS;
+}
+
+int uv_timer_init(uv_loop_t* arg0, uv_timer_t* handle) {
+  UV__UNUSED(arg0);
+  UV__UNUSED(handle);
+  return UV_ENOSYS;
+}
+
+int uv_timer_start(uv_timer_t* handle, uv_timer_cb cb, uint64_t timeout, uint64_t repeat) {
+  UV__UNUSED(handle);
+  UV__UNUSED(cb);
+  UV__UNUSED(timeout);
+  UV__UNUSED(repeat);
+  return UV_ENOSYS;
+}
+
+int uv_timer_stop(uv_timer_t* handle) {
+  UV__UNUSED(handle);
+  return UV_ENOSYS;
+}
+
+int uv_timer_again(uv_timer_t* handle) {
+  UV__UNUSED(handle);
+  return UV_ENOSYS;
+}
+
+void uv_timer_set_repeat(uv_timer_t* handle, uint64_t repeat) {
+  UV__UNUSED(handle);
+  UV__UNUSED(repeat);
+}
+
+uint64_t uv_timer_get_repeat(const uv_timer_t* handle) {
+  UV__UNUSED(handle);
+  return 0;
+}
+
+uint64_t uv_timer_get_due_in(const uv_timer_t* handle) {
+  UV__UNUSED(handle);
+  return 0;
+}
+
+int uv_getaddrinfo(uv_loop_t* loop, uv_getaddrinfo_t* req, uv_getaddrinfo_cb getaddrinfo_cb, const char* node, const char* service, const struct addrinfo* hints) {
+  UV__UNUSED(loop);
+  UV__UNUSED(req);
+  UV__UNUSED(getaddrinfo_cb);
+  UV__UNUSED(node);
+  UV__UNUSED(service);
+  UV__UNUSED(hints);
+  return UV_ENOSYS;
+}
+
+void uv_freeaddrinfo(struct addrinfo* ai) {
+  UV__UNUSED(ai);
+}
+
+int uv_getnameinfo(uv_loop_t* loop, uv_getnameinfo_t* req, uv_getnameinfo_cb getnameinfo_cb, const struct sockaddr* addr, int flags) {
+  UV__UNUSED(loop);
+  UV__UNUSED(req);
+  UV__UNUSED(getnameinfo_cb);
+  UV__UNUSED(addr);
+  UV__UNUSED(flags);
+  return UV_ENOSYS;
+}
+
+int uv_spawn(uv_loop_t* loop, uv_process_t* handle, const uv_process_options_t* options) {
+  UV__UNUSED(loop);
+  UV__UNUSED(handle);
+  UV__UNUSED(options);
+  return UV_ENOSYS;
+}
+
+int uv_process_kill(uv_process_t* arg0, int signum) {
+  UV__UNUSED(arg0);
+  UV__UNUSED(signum);
+  return UV_ENOSYS;
+}
+
+int uv_kill(int pid, int signum) {
+  UV__UNUSED(pid);
+  UV__UNUSED(signum);
+  return UV_ENOSYS;
+}
+
+uv_pid_t uv_process_get_pid(const uv_process_t* arg0) {
+  UV__UNUSED(arg0);
+  return UV_ENOSYS;
+}
+
+int uv_queue_work(uv_loop_t* loop, uv_work_t* req, uv_work_cb work_cb, uv_after_work_cb after_work_cb) {
+  UV__UNUSED(loop); if (req == NULL || work_cb == NULL || after_work_cb == NULL) return UV_EINVAL; work_cb(req); after_work_cb(req, 0); return 0;
+}
+
+int uv_cancel(uv_req_t* req) {
+  UV__UNUSED(req);
+  return UV_ENOSYS;
+}
+
+char** uv_setup_args(int argc, char** argv) {
+  UV__UNUSED(argc);
+  UV__UNUSED(argv);
+  return NULL;
+}
+
+int uv_get_process_title(char* buffer, size_t size) {
+  UV__UNUSED(buffer);
+  UV__UNUSED(size);
+  return UV_ENOSYS;
+}
+
+int uv_set_process_title(const char* title) {
+  UV__UNUSED(title);
+  return UV_ENOSYS;
+}
+
+int uv_resident_set_memory(size_t* rss) {
+  UV__UNUSED(rss);
+  return UV_ENOSYS;
+}
+
+int uv_uptime(double* uptime) {
+  UV__UNUSED(uptime);
+  return UV_ENOSYS;
+}
+
+uv_os_fd_t uv_get_osfhandle(int fd) {
+  UV__UNUSED(fd);
+  return UV_ENOSYS;
+}
+
+int uv_open_osfhandle(uv_os_fd_t os_fd) {
+  UV__UNUSED(os_fd);
+  return UV_ENOSYS;
+}
+
+int uv_getrusage(uv_rusage_t* rusage) {
+  UV__UNUSED(rusage);
+  return UV_ENOSYS;
+}
+
+int uv_getrusage_thread(uv_rusage_t* rusage) {
+  UV__UNUSED(rusage);
+  return UV_ENOSYS;
+}
+
+int uv_os_homedir(char* buffer, size_t* size) {
+  UV__UNUSED(buffer);
+  UV__UNUSED(size);
+  return UV_ENOSYS;
+}
+
+int uv_os_tmpdir(char* buffer, size_t* size) {
+  UV__UNUSED(buffer);
+  UV__UNUSED(size);
+  return UV_ENOSYS;
+}
+
+int uv_os_get_passwd(uv_passwd_t* pwd) {
+  UV__UNUSED(pwd);
+  return UV_ENOSYS;
+}
+
+void uv_os_free_passwd(uv_passwd_t* pwd) {
+  UV__UNUSED(pwd);
+}
+
+int uv_os_get_passwd2(uv_passwd_t* pwd, uv_uid_t uid) {
+  UV__UNUSED(pwd);
+  UV__UNUSED(uid);
+  return UV_ENOSYS;
+}
+
+int uv_os_get_group(uv_group_t* grp, uv_uid_t gid) {
+  UV__UNUSED(grp);
+  UV__UNUSED(gid);
+  return UV_ENOSYS;
+}
+
+void uv_os_free_group(uv_group_t* grp) {
+  UV__UNUSED(grp);
+}
+
+uv_pid_t uv_os_getpid(void) {
+  return UV_ENOSYS;
+}
+
+uv_pid_t uv_os_getppid(void) {
+  return UV_ENOSYS;
+}
+
+int uv_os_getpriority(uv_pid_t pid, int* priority) {
+  UV__UNUSED(pid);
+  UV__UNUSED(priority);
+  return UV_ENOSYS;
+}
+
+int uv_os_setpriority(uv_pid_t pid, int priority) {
+  UV__UNUSED(pid);
+  UV__UNUSED(priority);
+  return UV_ENOSYS;
+}
+
+int uv_thread_getpriority(uv_thread_t tid, int* priority) {
+  UV__UNUSED(tid);
+  UV__UNUSED(priority);
+  return UV_ENOSYS;
+}
+
+int uv_thread_setpriority(uv_thread_t tid, int priority) {
+  UV__UNUSED(tid);
+  UV__UNUSED(priority);
+  return UV_ENOSYS;
+}
+
+unsigned int uv_available_parallelism(void) {
+  return 0;
+}
+
+int uv_cpu_info(uv_cpu_info_t** cpu_infos, int* count) {
+  UV__UNUSED(cpu_infos);
+  UV__UNUSED(count);
+  return UV_ENOSYS;
+}
+
+void uv_free_cpu_info(uv_cpu_info_t* cpu_infos, int count) {
+  UV__UNUSED(cpu_infos);
+  UV__UNUSED(count);
+}
+
+int uv_cpumask_size(void) {
+  return UV_ENOSYS;
+}
+
+int uv_interface_addresses(uv_interface_address_t** addresses, int* count) {
+  UV__UNUSED(addresses);
+  UV__UNUSED(count);
+  return UV_ENOSYS;
+}
+
+void uv_free_interface_addresses(uv_interface_address_t* addresses, int count) {
+  UV__UNUSED(addresses);
+  UV__UNUSED(count);
+}
+
+int uv_os_environ(uv_env_item_t** envitems, int* count) {
+  UV__UNUSED(envitems);
+  UV__UNUSED(count);
+  return UV_ENOSYS;
+}
+
+void uv_os_free_environ(uv_env_item_t* envitems, int count) {
+  UV__UNUSED(envitems);
+  UV__UNUSED(count);
+}
+
+int uv_os_getenv(const char* name, char* buffer, size_t* size) {
+  UV__UNUSED(name);
+  UV__UNUSED(buffer);
+  UV__UNUSED(size);
+  return UV_ENOSYS;
+}
+
+int uv_os_setenv(const char* name, const char* value) {
+  UV__UNUSED(name);
+  UV__UNUSED(value);
+  return UV_ENOSYS;
+}
+
+int uv_os_unsetenv(const char* name) {
+  UV__UNUSED(name);
+  return UV_ENOSYS;
+}
+
+int uv_os_gethostname(char* buffer, size_t* size) {
+  UV__UNUSED(buffer);
+  UV__UNUSED(size);
+  return UV_ENOSYS;
+}
+
+int uv_os_uname(uv_utsname_t* buffer) {
+  UV__UNUSED(buffer);
+  return UV_ENOSYS;
+}
+
+int uv_metrics_info(uv_loop_t* loop, uv_metrics_t* metrics) {
+  UV__UNUSED(loop);
+  UV__UNUSED(metrics);
+  return UV_ENOSYS;
+}
+
+uint64_t uv_metrics_idle_time(uv_loop_t* loop) {
+  UV__UNUSED(loop);
+  return 0;
+}
+
+uv_fs_type uv_fs_get_type(const uv_fs_t* arg0) {
+  UV__UNUSED(arg0);
+  return 0;
+}
+
+ssize_t uv_fs_get_result(const uv_fs_t* arg0) {
+  UV__UNUSED(arg0);
+  return 0;
+}
+
+int uv_fs_get_system_error(const uv_fs_t* arg0) {
+  UV__UNUSED(arg0);
+  return UV_ENOSYS;
+}
+
+void* uv_fs_get_ptr(const uv_fs_t* arg0) {
+  UV__UNUSED(arg0);
+  return NULL;
+}
+
+const char* uv_fs_get_path(const uv_fs_t* arg0) {
+  UV__UNUSED(arg0);
+  return NULL;
+}
+
+uv_stat_t* uv_fs_get_statbuf(uv_fs_t* arg0) {
+  UV__UNUSED(arg0);
+  return NULL;
+}
+
+void uv_fs_req_cleanup(uv_fs_t* req) {
+  UV__UNUSED(req);
+}
+
+int uv_fs_close(uv_loop_t* loop, uv_fs_t* req, uv_file file, uv_fs_cb cb) {
+  UV__UNUSED(loop);
+  UV__UNUSED(req);
+  UV__UNUSED(file);
+  UV__UNUSED(cb);
+  return UV_ENOSYS;
+}
+
+int uv_fs_open(uv_loop_t* loop, uv_fs_t* req, const char* path, int flags, int mode, uv_fs_cb cb) {
+  UV__UNUSED(loop);
+  UV__UNUSED(req);
+  UV__UNUSED(path);
+  UV__UNUSED(flags);
+  UV__UNUSED(mode);
+  UV__UNUSED(cb);
+  return UV_ENOSYS;
+}
+
+int uv_fs_read(uv_loop_t* loop, uv_fs_t* req, uv_file file, const uv_buf_t bufs[], unsigned int nbufs, int64_t offset, uv_fs_cb cb) {
+  UV__UNUSED(loop);
+  UV__UNUSED(req);
+  UV__UNUSED(file);
+  UV__UNUSED(bufs);
+  UV__UNUSED(nbufs);
+  UV__UNUSED(offset);
+  UV__UNUSED(cb);
+  return UV_ENOSYS;
+}
+
+int uv_fs_unlink(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_fs_cb cb) {
+  UV__UNUSED(loop);
+  UV__UNUSED(req);
+  UV__UNUSED(path);
+  UV__UNUSED(cb);
+  return UV_ENOSYS;
+}
+
+int uv_fs_write(uv_loop_t* loop, uv_fs_t* req, uv_file file, const uv_buf_t bufs[], unsigned int nbufs, int64_t offset, uv_fs_cb cb) {
+  UV__UNUSED(loop);
+  UV__UNUSED(req);
+  UV__UNUSED(file);
+  UV__UNUSED(bufs);
+  UV__UNUSED(nbufs);
+  UV__UNUSED(offset);
+  UV__UNUSED(cb);
+  return UV_ENOSYS;
+}
+
+int uv_fs_copyfile(uv_loop_t* loop, uv_fs_t* req, const char* path, const char* new_path, int flags, uv_fs_cb cb) {
+  UV__UNUSED(loop);
+  UV__UNUSED(req);
+  UV__UNUSED(path);
+  UV__UNUSED(new_path);
+  UV__UNUSED(flags);
+  UV__UNUSED(cb);
+  return UV_ENOSYS;
+}
+
+int uv_fs_mkdir(uv_loop_t* loop, uv_fs_t* req, const char* path, int mode, uv_fs_cb cb) {
+  UV__UNUSED(loop);
+  UV__UNUSED(req);
+  UV__UNUSED(path);
+  UV__UNUSED(mode);
+  UV__UNUSED(cb);
+  return UV_ENOSYS;
+}
+
+int uv_fs_mkdtemp(uv_loop_t* loop, uv_fs_t* req, const char* tpl, uv_fs_cb cb) {
+  UV__UNUSED(loop);
+  UV__UNUSED(req);
+  UV__UNUSED(tpl);
+  UV__UNUSED(cb);
+  return UV_ENOSYS;
+}
+
+int uv_fs_mkstemp(uv_loop_t* loop, uv_fs_t* req, const char* tpl, uv_fs_cb cb) {
+  UV__UNUSED(loop);
+  UV__UNUSED(req);
+  UV__UNUSED(tpl);
+  UV__UNUSED(cb);
+  return UV_ENOSYS;
+}
+
+int uv_fs_rmdir(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_fs_cb cb) {
+  UV__UNUSED(loop);
+  UV__UNUSED(req);
+  UV__UNUSED(path);
+  UV__UNUSED(cb);
+  return UV_ENOSYS;
+}
+
+int uv_fs_scandir(uv_loop_t* loop, uv_fs_t* req, const char* path, int flags, uv_fs_cb cb) {
+  UV__UNUSED(loop);
+  UV__UNUSED(req);
+  UV__UNUSED(path);
+  UV__UNUSED(flags);
+  UV__UNUSED(cb);
+  return UV_ENOSYS;
+}
+
+int uv_fs_scandir_next(uv_fs_t* req, uv_dirent_t* ent) {
+  UV__UNUSED(req);
+  UV__UNUSED(ent);
+  return UV_ENOSYS;
+}
+
+int uv_fs_opendir(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_fs_cb cb) {
+  UV__UNUSED(loop);
+  UV__UNUSED(req);
+  UV__UNUSED(path);
+  UV__UNUSED(cb);
+  return UV_ENOSYS;
+}
+
+int uv_fs_readdir(uv_loop_t* loop, uv_fs_t* req, uv_dir_t* dir, uv_fs_cb cb) {
+  UV__UNUSED(loop);
+  UV__UNUSED(req);
+  UV__UNUSED(dir);
+  UV__UNUSED(cb);
+  return UV_ENOSYS;
+}
+
+int uv_fs_closedir(uv_loop_t* loop, uv_fs_t* req, uv_dir_t* dir, uv_fs_cb cb) {
+  UV__UNUSED(loop);
+  UV__UNUSED(req);
+  UV__UNUSED(dir);
+  UV__UNUSED(cb);
+  return UV_ENOSYS;
+}
+
+int uv_fs_stat(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_fs_cb cb) {
+  UV__UNUSED(loop);
+  UV__UNUSED(req);
+  UV__UNUSED(path);
+  UV__UNUSED(cb);
+  return UV_ENOSYS;
+}
+
+int uv_fs_fstat(uv_loop_t* loop, uv_fs_t* req, uv_file file, uv_fs_cb cb) {
+  UV__UNUSED(loop);
+  UV__UNUSED(req);
+  UV__UNUSED(file);
+  UV__UNUSED(cb);
+  return UV_ENOSYS;
+}
+
+int uv_fs_rename(uv_loop_t* loop, uv_fs_t* req, const char* path, const char* new_path, uv_fs_cb cb) {
+  UV__UNUSED(loop);
+  UV__UNUSED(req);
+  UV__UNUSED(path);
+  UV__UNUSED(new_path);
+  UV__UNUSED(cb);
+  return UV_ENOSYS;
+}
+
+int uv_fs_fsync(uv_loop_t* loop, uv_fs_t* req, uv_file file, uv_fs_cb cb) {
+  UV__UNUSED(loop);
+  UV__UNUSED(req);
+  UV__UNUSED(file);
+  UV__UNUSED(cb);
+  return UV_ENOSYS;
+}
+
+int uv_fs_fdatasync(uv_loop_t* loop, uv_fs_t* req, uv_file file, uv_fs_cb cb) {
+  UV__UNUSED(loop);
+  UV__UNUSED(req);
+  UV__UNUSED(file);
+  UV__UNUSED(cb);
+  return UV_ENOSYS;
+}
+
+int uv_fs_ftruncate(uv_loop_t* loop, uv_fs_t* req, uv_file file, int64_t offset, uv_fs_cb cb) {
+  UV__UNUSED(loop);
+  UV__UNUSED(req);
+  UV__UNUSED(file);
+  UV__UNUSED(offset);
+  UV__UNUSED(cb);
+  return UV_ENOSYS;
+}
+
+int uv_fs_sendfile(uv_loop_t* loop, uv_fs_t* req, uv_file out_fd, uv_file in_fd, int64_t in_offset, size_t length, uv_fs_cb cb) {
+  UV__UNUSED(loop);
+  UV__UNUSED(req);
+  UV__UNUSED(out_fd);
+  UV__UNUSED(in_fd);
+  UV__UNUSED(in_offset);
+  UV__UNUSED(length);
+  UV__UNUSED(cb);
+  return UV_ENOSYS;
+}
+
+int uv_fs_access(uv_loop_t* loop, uv_fs_t* req, const char* path, int mode, uv_fs_cb cb) {
+  UV__UNUSED(loop);
+  UV__UNUSED(req);
+  UV__UNUSED(path);
+  UV__UNUSED(mode);
+  UV__UNUSED(cb);
+  return UV_ENOSYS;
+}
+
+int uv_fs_chmod(uv_loop_t* loop, uv_fs_t* req, const char* path, int mode, uv_fs_cb cb) {
+  UV__UNUSED(loop);
+  UV__UNUSED(req);
+  UV__UNUSED(path);
+  UV__UNUSED(mode);
+  UV__UNUSED(cb);
+  return UV_ENOSYS;
+}
+
+int uv_fs_utime(uv_loop_t* loop, uv_fs_t* req, const char* path, double atime, double mtime, uv_fs_cb cb) {
+  UV__UNUSED(loop);
+  UV__UNUSED(req);
+  UV__UNUSED(path);
+  UV__UNUSED(atime);
+  UV__UNUSED(mtime);
+  UV__UNUSED(cb);
+  return UV_ENOSYS;
+}
+
+int uv_fs_futime(uv_loop_t* loop, uv_fs_t* req, uv_file file, double atime, double mtime, uv_fs_cb cb) {
+  UV__UNUSED(loop);
+  UV__UNUSED(req);
+  UV__UNUSED(file);
+  UV__UNUSED(atime);
+  UV__UNUSED(mtime);
+  UV__UNUSED(cb);
+  return UV_ENOSYS;
+}
+
+int uv_fs_lutime(uv_loop_t* loop, uv_fs_t* req, const char* path, double atime, double mtime, uv_fs_cb cb) {
+  UV__UNUSED(loop);
+  UV__UNUSED(req);
+  UV__UNUSED(path);
+  UV__UNUSED(atime);
+  UV__UNUSED(mtime);
+  UV__UNUSED(cb);
+  return UV_ENOSYS;
+}
+
+int uv_fs_lstat(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_fs_cb cb) {
+  UV__UNUSED(loop);
+  UV__UNUSED(req);
+  UV__UNUSED(path);
+  UV__UNUSED(cb);
+  return UV_ENOSYS;
+}
+
+int uv_fs_link(uv_loop_t* loop, uv_fs_t* req, const char* path, const char* new_path, uv_fs_cb cb) {
+  UV__UNUSED(loop);
+  UV__UNUSED(req);
+  UV__UNUSED(path);
+  UV__UNUSED(new_path);
+  UV__UNUSED(cb);
+  return UV_ENOSYS;
+}
+
+int uv_fs_symlink(uv_loop_t* loop, uv_fs_t* req, const char* path, const char* new_path, int flags, uv_fs_cb cb) {
+  UV__UNUSED(loop);
+  UV__UNUSED(req);
+  UV__UNUSED(path);
+  UV__UNUSED(new_path);
+  UV__UNUSED(flags);
+  UV__UNUSED(cb);
+  return UV_ENOSYS;
+}
+
+int uv_fs_readlink(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_fs_cb cb) {
+  UV__UNUSED(loop);
+  UV__UNUSED(req);
+  UV__UNUSED(path);
+  UV__UNUSED(cb);
+  return UV_ENOSYS;
+}
+
+int uv_fs_realpath(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_fs_cb cb) {
+  UV__UNUSED(loop);
+  UV__UNUSED(req);
+  UV__UNUSED(path);
+  UV__UNUSED(cb);
+  return UV_ENOSYS;
+}
+
+int uv_fs_fchmod(uv_loop_t* loop, uv_fs_t* req, uv_file file, int mode, uv_fs_cb cb) {
+  UV__UNUSED(loop);
+  UV__UNUSED(req);
+  UV__UNUSED(file);
+  UV__UNUSED(mode);
+  UV__UNUSED(cb);
+  return UV_ENOSYS;
+}
+
+int uv_fs_chown(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_uid_t uid, uv_gid_t gid, uv_fs_cb cb) {
+  UV__UNUSED(loop);
+  UV__UNUSED(req);
+  UV__UNUSED(path);
+  UV__UNUSED(uid);
+  UV__UNUSED(gid);
+  UV__UNUSED(cb);
+  return UV_ENOSYS;
+}
+
+int uv_fs_fchown(uv_loop_t* loop, uv_fs_t* req, uv_file file, uv_uid_t uid, uv_gid_t gid, uv_fs_cb cb) {
+  UV__UNUSED(loop);
+  UV__UNUSED(req);
+  UV__UNUSED(file);
+  UV__UNUSED(uid);
+  UV__UNUSED(gid);
+  UV__UNUSED(cb);
+  return UV_ENOSYS;
+}
+
+int uv_fs_lchown(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_uid_t uid, uv_gid_t gid, uv_fs_cb cb) {
+  UV__UNUSED(loop);
+  UV__UNUSED(req);
+  UV__UNUSED(path);
+  UV__UNUSED(uid);
+  UV__UNUSED(gid);
+  UV__UNUSED(cb);
+  return UV_ENOSYS;
+}
+
+int uv_fs_statfs(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_fs_cb cb) {
+  UV__UNUSED(loop);
+  UV__UNUSED(req);
+  UV__UNUSED(path);
+  UV__UNUSED(cb);
+  return UV_ENOSYS;
+}
+
+int uv_fs_poll_init(uv_loop_t* loop, uv_fs_poll_t* handle) {
+  UV__UNUSED(loop);
+  UV__UNUSED(handle);
+  return UV_ENOSYS;
+}
+
+int uv_fs_poll_start(uv_fs_poll_t* handle, uv_fs_poll_cb poll_cb, const char* path, unsigned int interval) {
+  UV__UNUSED(handle);
+  UV__UNUSED(poll_cb);
+  UV__UNUSED(path);
+  UV__UNUSED(interval);
+  return UV_ENOSYS;
+}
+
+int uv_fs_poll_stop(uv_fs_poll_t* handle) {
+  UV__UNUSED(handle);
+  return UV_ENOSYS;
+}
+
+int uv_fs_poll_getpath(uv_fs_poll_t* handle, char* buffer, size_t* size) {
+  UV__UNUSED(handle);
+  UV__UNUSED(buffer);
+  UV__UNUSED(size);
+  return UV_ENOSYS;
+}
+
+int uv_signal_init(uv_loop_t* loop, uv_signal_t* handle) {
+  UV__UNUSED(loop);
+  UV__UNUSED(handle);
+  return UV_ENOSYS;
+}
+
+int uv_signal_start(uv_signal_t* handle, uv_signal_cb signal_cb, int signum) {
+  UV__UNUSED(handle);
+  UV__UNUSED(signal_cb);
+  UV__UNUSED(signum);
+  return UV_ENOSYS;
+}
+
+int uv_signal_start_oneshot(uv_signal_t* handle, uv_signal_cb signal_cb, int signum) {
+  UV__UNUSED(handle);
+  UV__UNUSED(signal_cb);
+  UV__UNUSED(signum);
+  return UV_ENOSYS;
+}
+
+int uv_signal_stop(uv_signal_t* handle) {
+  UV__UNUSED(handle);
+  return UV_ENOSYS;
+}
+
+void uv_loadavg(double avg[3]) {
+  UV__UNUSED(avg);
+}
+
+int uv_fs_event_init(uv_loop_t* loop, uv_fs_event_t* handle) {
+  UV__UNUSED(loop);
+  UV__UNUSED(handle);
+  return UV_ENOSYS;
+}
+
+int uv_fs_event_start(uv_fs_event_t* handle, uv_fs_event_cb cb, const char* path, unsigned int flags) {
+  UV__UNUSED(handle);
+  UV__UNUSED(cb);
+  UV__UNUSED(path);
+  UV__UNUSED(flags);
+  return UV_ENOSYS;
+}
+
+int uv_fs_event_stop(uv_fs_event_t* handle) {
+  UV__UNUSED(handle);
+  return UV_ENOSYS;
+}
+
+int uv_fs_event_getpath(uv_fs_event_t* handle, char* buffer, size_t* size) {
+  UV__UNUSED(handle);
+  UV__UNUSED(buffer);
+  UV__UNUSED(size);
+  return UV_ENOSYS;
+}
+
+int uv_ip4_addr(const char* ip, int port, struct sockaddr_in* addr) {
+  UV__UNUSED(ip);
+  UV__UNUSED(port);
+  UV__UNUSED(addr);
+  return UV_ENOSYS;
+}
+
+int uv_ip6_addr(const char* ip, int port, struct sockaddr_in6* addr) {
+  UV__UNUSED(ip);
+  UV__UNUSED(port);
+  UV__UNUSED(addr);
+  return UV_ENOSYS;
+}
+
+int uv_ip4_name(const struct sockaddr_in* src, char* dst, size_t size) {
+  UV__UNUSED(src);
+  UV__UNUSED(dst);
+  UV__UNUSED(size);
+  return UV_ENOSYS;
+}
+
+int uv_ip6_name(const struct sockaddr_in6* src, char* dst, size_t size) {
+  UV__UNUSED(src);
+  UV__UNUSED(dst);
+  UV__UNUSED(size);
+  return UV_ENOSYS;
+}
+
+int uv_ip_name(const struct sockaddr* src, char* dst, size_t size) {
+  UV__UNUSED(src);
+  UV__UNUSED(dst);
+  UV__UNUSED(size);
+  return UV_ENOSYS;
+}
+
+int uv_inet_ntop(int af, const void* src, char* dst, size_t size) {
+  UV__UNUSED(af);
+  UV__UNUSED(src);
+  UV__UNUSED(dst);
+  UV__UNUSED(size);
+  return UV_ENOSYS;
+}
+
+int uv_inet_pton(int af, const char* src, void* dst) {
+  UV__UNUSED(af);
+  UV__UNUSED(src);
+  UV__UNUSED(dst);
+  return UV_ENOSYS;
+}
+
+int uv_random(uv_loop_t* loop, uv_random_t* req, void *buf, size_t buflen, unsigned flags, /* For future extension; must be 0. */ uv_random_cb cb) {
+  UV__UNUSED(loop);
+  UV__UNUSED(req);
+  UV__UNUSED(buf);
+  UV__UNUSED(buflen);
+  UV__UNUSED(flags);
+  UV__UNUSED(cb);
+  return UV_ENOSYS;
+}
+
+int uv_if_indextoname(unsigned int ifindex, char* buffer, size_t* size) {
+  UV__UNUSED(ifindex);
+  UV__UNUSED(buffer);
+  UV__UNUSED(size);
+  return UV_ENOSYS;
+}
+
+int uv_if_indextoiid(unsigned int ifindex, char* buffer, size_t* size) {
+  UV__UNUSED(ifindex);
+  UV__UNUSED(buffer);
+  UV__UNUSED(size);
+  return UV_ENOSYS;
+}
+
+int uv_exepath(char* buffer, size_t* size) {
+  UV__UNUSED(buffer);
+  UV__UNUSED(size);
+  return UV_ENOSYS;
+}
+
+int uv_cwd(char* buffer, size_t* size) {
+  UV__UNUSED(buffer);
+  UV__UNUSED(size);
+  return UV_ENOSYS;
+}
+
+int uv_chdir(const char* dir) {
+  UV__UNUSED(dir);
+  return UV_ENOSYS;
+}
+
+uint64_t uv_get_free_memory(void) {
+  return 0;
+}
+
+uint64_t uv_get_total_memory(void) {
+  return 0;
+}
+
+uint64_t uv_get_constrained_memory(void) {
+  return 0;
+}
+
+uint64_t uv_get_available_memory(void) {
+  return 0;
+}
+
+int uv_clock_gettime(uv_clock_id clock_id, uv_timespec64_t* ts) {
+  UV__UNUSED(clock_id);
+  UV__UNUSED(ts);
+  return UV_ENOSYS;
+}
+
+uint64_t uv_hrtime(void) {
+  return 0;
+}
+
+void uv_sleep(unsigned int msec) {
+  UV__UNUSED(msec);
+}
+
+void uv_disable_stdio_inheritance(void) {
+
+}
+
+int uv_dlopen(const char* filename, uv_lib_t* lib) {
+  UV__UNUSED(filename);
+  UV__UNUSED(lib);
+  return UV_ENOSYS;
+}
+
+void uv_dlclose(uv_lib_t* lib) {
+  UV__UNUSED(lib);
+}
+
+int uv_dlsym(uv_lib_t* lib, const char* name, void** ptr) {
+  UV__UNUSED(lib);
+  UV__UNUSED(name);
+  UV__UNUSED(ptr);
+  return UV_ENOSYS;
+}
+
+const char* uv_dlerror(const uv_lib_t* lib) {
+  UV__UNUSED(lib);
+  return NULL;
+}
+
+int uv_mutex_init(uv_mutex_t* handle) {
+  UV__UNUSED(handle);
+  return UV_ENOSYS;
+}
+
+int uv_mutex_init_recursive(uv_mutex_t* handle) {
+  UV__UNUSED(handle);
+  return UV_ENOSYS;
+}
+
+void uv_mutex_destroy(uv_mutex_t* handle) {
+  UV__UNUSED(handle);
+}
+
+void uv_mutex_lock(uv_mutex_t* handle) {
+  UV__UNUSED(handle);
+}
+
+int uv_mutex_trylock(uv_mutex_t* handle) {
+  UV__UNUSED(handle);
+  return UV_ENOSYS;
+}
+
+void uv_mutex_unlock(uv_mutex_t* handle) {
+  UV__UNUSED(handle);
+}
+
+int uv_rwlock_init(uv_rwlock_t* rwlock) {
+  UV__UNUSED(rwlock);
+  return UV_ENOSYS;
+}
+
+void uv_rwlock_destroy(uv_rwlock_t* rwlock) {
+  UV__UNUSED(rwlock);
+}
+
+void uv_rwlock_rdlock(uv_rwlock_t* rwlock) {
+  UV__UNUSED(rwlock);
+}
+
+int uv_rwlock_tryrdlock(uv_rwlock_t* rwlock) {
+  UV__UNUSED(rwlock);
+  return UV_ENOSYS;
+}
+
+void uv_rwlock_rdunlock(uv_rwlock_t* rwlock) {
+  UV__UNUSED(rwlock);
+}
+
+void uv_rwlock_wrlock(uv_rwlock_t* rwlock) {
+  UV__UNUSED(rwlock);
+}
+
+int uv_rwlock_trywrlock(uv_rwlock_t* rwlock) {
+  UV__UNUSED(rwlock);
+  return UV_ENOSYS;
+}
+
+void uv_rwlock_wrunlock(uv_rwlock_t* rwlock) {
+  UV__UNUSED(rwlock);
+}
+
+int uv_sem_init(uv_sem_t* sem, unsigned int value) {
+  UV__UNUSED(sem);
+  UV__UNUSED(value);
+  return UV_ENOSYS;
+}
+
+void uv_sem_destroy(uv_sem_t* sem) {
+  UV__UNUSED(sem);
+}
+
+void uv_sem_post(uv_sem_t* sem) {
+  UV__UNUSED(sem);
+}
+
+void uv_sem_wait(uv_sem_t* sem) {
+  UV__UNUSED(sem);
+}
+
+int uv_sem_trywait(uv_sem_t* sem) {
+  UV__UNUSED(sem);
+  return UV_ENOSYS;
+}
+
+int uv_cond_init(uv_cond_t* cond) {
+  UV__UNUSED(cond);
+  return UV_ENOSYS;
+}
+
+void uv_cond_destroy(uv_cond_t* cond) {
+  UV__UNUSED(cond);
+}
+
+void uv_cond_signal(uv_cond_t* cond) {
+  UV__UNUSED(cond);
+}
+
+void uv_cond_broadcast(uv_cond_t* cond) {
+  UV__UNUSED(cond);
+}
+
+int uv_barrier_init(uv_barrier_t* barrier, unsigned int count) {
+  UV__UNUSED(barrier);
+  UV__UNUSED(count);
+  return UV_ENOSYS;
+}
+
+void uv_barrier_destroy(uv_barrier_t* barrier) {
+  UV__UNUSED(barrier);
+}
+
+int uv_barrier_wait(uv_barrier_t* barrier) {
+  UV__UNUSED(barrier);
+  return UV_ENOSYS;
+}
+
+void uv_cond_wait(uv_cond_t* cond, uv_mutex_t* mutex) {
+  UV__UNUSED(cond);
+  UV__UNUSED(mutex);
+}
+
+int uv_cond_timedwait(uv_cond_t* cond, uv_mutex_t* mutex, uint64_t timeout) {
+  UV__UNUSED(cond);
+  UV__UNUSED(mutex);
+  UV__UNUSED(timeout);
+  return UV_ENOSYS;
+}
+
+void uv_once(uv_once_t* guard, void (*callback)(void)) {
+  UV__UNUSED(guard);
+  UV__UNUSED(callback);
+}
+
+int uv_key_create(uv_key_t* key) {
+  UV__UNUSED(key);
+  return UV_ENOSYS;
+}
+
+void uv_key_delete(uv_key_t* key) {
+  UV__UNUSED(key);
+}
+
+void* uv_key_get(uv_key_t* key) {
+  UV__UNUSED(key);
+  return NULL;
+}
+
+void uv_key_set(uv_key_t* key, void* value) {
+  UV__UNUSED(key);
+  UV__UNUSED(value);
+}
+
+int uv_gettimeofday(uv_timeval64_t* tv) {
+  UV__UNUSED(tv);
+  return UV_ENOSYS;
+}
+
+int uv_thread_create(uv_thread_t* tid, uv_thread_cb entry, void* arg) {
+  UV__UNUSED(tid);
+  UV__UNUSED(entry);
+  UV__UNUSED(arg);
+  return UV_ENOSYS;
+}
+
+int uv_thread_detach(uv_thread_t* tid) {
+  UV__UNUSED(tid);
+  return UV_ENOSYS;
+}
+
+int uv_thread_create_ex(uv_thread_t* tid, const uv_thread_options_t* params, uv_thread_cb entry, void* arg) {
+  UV__UNUSED(tid);
+  UV__UNUSED(params);
+  UV__UNUSED(entry);
+  UV__UNUSED(arg);
+  return UV_ENOSYS;
+}
+
+int uv_thread_setaffinity(uv_thread_t* tid, char* cpumask, char* oldmask, size_t mask_size) {
+  UV__UNUSED(tid);
+  UV__UNUSED(cpumask);
+  UV__UNUSED(oldmask);
+  UV__UNUSED(mask_size);
+  return UV_ENOSYS;
+}
+
+int uv_thread_getaffinity(uv_thread_t* tid, char* cpumask, size_t mask_size) {
+  UV__UNUSED(tid);
+  UV__UNUSED(cpumask);
+  UV__UNUSED(mask_size);
+  return UV_ENOSYS;
+}
+
+int uv_thread_getcpu(void) {
+  return UV_ENOSYS;
+}
+
+uv_thread_t uv_thread_self(void) {
+  uv_thread_t out; memset(&out, 0, sizeof(out)); return out;
+}
+
+int uv_thread_join(uv_thread_t *tid) {
+  UV__UNUSED(tid);
+  return UV_ENOSYS;
+}
+
+int uv_thread_equal(const uv_thread_t* t1, const uv_thread_t* t2) {
+  UV__UNUSED(t1);
+  UV__UNUSED(t2);
+  return UV_ENOSYS;
+}
+
+int uv_thread_setname(const char* name) {
+  UV__UNUSED(name);
+  return UV_ENOSYS;
+}
+
+int uv_thread_getname(uv_thread_t* tid, char* name, size_t size) {
+  UV__UNUSED(tid);
+  UV__UNUSED(name);
+  UV__UNUSED(size);
+  return UV_ENOSYS;
+}
+
+void* uv_loop_get_data(const uv_loop_t* arg0) {
+  UV__UNUSED(arg0);
+  return NULL;
+}
+
+void uv_loop_set_data(uv_loop_t* arg0, void* data) {
+  UV__UNUSED(arg0);
+  UV__UNUSED(data);
+}
+
+size_t uv_utf16_length_as_wtf8(const uint16_t* utf16, ssize_t utf16_len) {
+  UV__UNUSED(utf16);
+  UV__UNUSED(utf16_len);
+  return 0;
+}
+
+int uv_utf16_to_wtf8(const uint16_t* utf16, ssize_t utf16_len, char** wtf8_ptr, size_t* wtf8_len_ptr) {
+  UV__UNUSED(utf16);
+  UV__UNUSED(utf16_len);
+  UV__UNUSED(wtf8_ptr);
+  UV__UNUSED(wtf8_len_ptr);
+  return UV_ENOSYS;
+}
+
+ssize_t uv_wtf8_length_as_utf16(const char* wtf8) {
+  UV__UNUSED(wtf8);
+  return 0;
+}
+
+void uv_wtf8_to_utf16(const char* wtf8, uint16_t* utf16, size_t utf16_len) {
+  UV__UNUSED(wtf8);
+  UV__UNUSED(utf16);
+  UV__UNUSED(utf16_len);
+}
