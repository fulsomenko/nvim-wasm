diff -ruN a/CMakeLists.txt b/CMakeLists.txt
--- a/CMakeLists.txt	2025-04-25 18:50:27.000000000 +0900
+++ b/CMakeLists.txt	2025-12-07 12:46:44.299901226 +0900
@@ -185,6 +185,23 @@
     src/uv-data-getter-setters.c
     src/version.c)
 
+if(CMAKE_SYSTEM_NAME STREQUAL "WASI"
+   OR CMAKE_C_COMPILER_TARGET MATCHES "wasm32.*wasi"
+   OR CMAKE_C_COMPILER MATCHES "wasi")
+  list(APPEND uv_defines __wasi__ _WASI_EMULATED_SIGNAL)
+  add_library(uv_a STATIC src/wasi/stub.c)
+  target_compile_definitions(uv_a PRIVATE ${uv_defines})
+  target_compile_options(uv_a PRIVATE ${uv_cflags})
+  target_include_directories(uv_a
+    PUBLIC
+      $<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}/include>
+      $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>)
+  set_target_properties(uv_a PROPERTIES OUTPUT_NAME "uv")
+  install(TARGETS uv_a ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR})
+  install(DIRECTORY include/ DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/)
+  return()
+endif()
+
 if(WIN32)
   list(APPEND uv_defines WIN32_LEAN_AND_MEAN _WIN32_WINNT=0x0A00 _CRT_DECLARE_NONSTDC_NAMES=0)
   list(APPEND uv_libraries
diff -ruN a/include/uv/unix.h b/include/uv/unix.h
--- a/include/uv/unix.h	2025-04-25 18:50:27.000000000 +0900
+++ b/include/uv/unix.h	2025-12-07 12:46:44.300026433 +0900
@@ -27,18 +27,27 @@
 #include <fcntl.h>
 #include <dirent.h>
 
+#if defined(__wasi__)
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <netinet/tcp.h>
+#include <arpa/inet.h>
+#include <sys/param.h>
+#else
 #include <sys/socket.h>
 #include <netinet/in.h>
 #include <netinet/tcp.h>
 #include <arpa/inet.h>
 #include <netdb.h>  /* MAXHOSTNAMELEN on Solaris */
-
 #include <termios.h>
 #include <pwd.h>
+# if !defined(__MVS__)
+#include <sys/param.h> /* MAXHOSTNAMELEN on Linux and the BSDs */
+# endif
+#endif
 
 #if !defined(__MVS__)
 #include <semaphore.h>
-#include <sys/param.h> /* MAXHOSTNAMELEN on Linux and the BSDs */
 #endif
 #include <pthread.h>
 #include <signal.h>
@@ -383,6 +392,11 @@
   struct termios orig_termios;                                                \
   int mode;
 
+#if defined(__wasi__)
+#undef UV_TTY_PRIVATE_FIELDS
+#define UV_TTY_PRIVATE_FIELDS int mode;
+#endif
+
 #define UV_SIGNAL_PRIVATE_FIELDS                                              \
   /* RB_ENTRY(uv_signal_s) tree_entry; */                                     \
   struct {                                                                    \
diff -ruN a/src/wasi/stub.c b/src/wasi/stub.c
--- a/src/wasi/stub.c
+++ b/src/wasi/stub.c
@@ -0,0 +1,2147 @@
+#include "uv.h"
+#include <string.h>
+#include <stdlib.h>
+#include <time.h>
+#include <unistd.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <limits.h>
+#ifndef F_DUPFD
+#define F_DUPFD 0
+#endif
+#ifndef F_DUPFD_CLOEXEC
+#define F_DUPFD_CLOEXEC 0x400
+#endif
+
+#define UV__UNUSED(x) ((void)(x))
+static int wasi_fill_x(char* path, unsigned attempt) {
+  static const char alpha[] = "abcdefghijklmnopqrstuvwxyz0123456789";
+  size_t n = strlen(path);
+  int count = 0;
+  for (size_t i = 0; i < n; i++) {
+    if (path[i] == 'X') {
+      path[i] = alpha[(attempt + (unsigned)i * 17U) % (sizeof(alpha) - 1)];
+      count++;
+    }
+  }
+  return count;
+}
+
+static char* wasi_mkdtemp(char* tpl) {
+  if (!tpl) {
+    errno = EINVAL;
+    return NULL;
+  }
+  char* orig = strdup(tpl);
+  if (!orig) {
+    errno = ENOMEM;
+    return NULL;
+  }
+  char* ret = NULL;
+  for (unsigned attempt = 0; attempt < 256; attempt++) {
+    strcpy(tpl, orig);
+    if (wasi_fill_x(tpl, attempt) == 0) {
+      errno = EINVAL;
+      break;
+    }
+    if (mkdir(tpl, 0700) == 0) {
+      ret = tpl;
+      break;
+    }
+    if (errno != EEXIST) {
+      break;
+    }
+  }
+  free(orig);
+  return ret;
+}
+
+static int wasi_mkstemp(char* tpl) {
+  if (!tpl) {
+    errno = EINVAL;
+    return -1;
+  }
+  char* orig = strdup(tpl);
+  if (!orig) {
+    errno = ENOMEM;
+    return -1;
+  }
+  int fd = -1;
+  for (unsigned attempt = 0; attempt < 256; attempt++) {
+    strcpy(tpl, orig);
+    if (wasi_fill_x(tpl, attempt) == 0) {
+      errno = EINVAL;
+      break;
+    }
+    fd = open(tpl, O_RDWR | O_CREAT | O_EXCL, 0600);
+    if (fd >= 0) {
+      break;
+    }
+    if (errno != EEXIST) {
+      break;
+    }
+  }
+  free(orig);
+  return fd;
+}
+
+int fcntl(int fd, int cmd, ...) {
+  if (cmd == F_DUPFD || cmd == F_DUPFD_CLOEXEC) {
+    return fd;  // Best effort: reuse same fd under WASI.
+  }
+  errno = ENOSYS;
+  return -1;
+}
+
+unsigned int uv_version(void) {
+  return UV_VERSION_HEX;
+}
+
+const char* uv_version_string(void) {
+  return "wasi-stub";
+}
+
+void uv_library_shutdown(void) {
+  return;
+}
+
+int uv_replace_allocator(uv_malloc_func malloc_func, uv_realloc_func realloc_func, uv_calloc_func calloc_func, uv_free_func free_func) {
+  UV__UNUSED(malloc_func); UV__UNUSED(realloc_func); UV__UNUSED(calloc_func); UV__UNUSED(free_func); return 0;
+}
+
+uv_loop_t* uv_default_loop(void) {
+  static uv_loop_t default_loop; return &default_loop;
+}
+
+int uv_loop_init(uv_loop_t* loop) {
+  if (loop) memset(loop, 0, sizeof(*loop)); return 0;
+}
+
+int uv_loop_close(uv_loop_t* loop) {
+  return 0;
+}
+
+uv_loop_t* uv_loop_new(void) {
+  uv_loop_t* loop = (uv_loop_t*)malloc(sizeof(uv_loop_t)); if (loop) memset(loop, 0, sizeof(*loop)); return loop;
+}
+
+void uv_loop_delete(uv_loop_t* arg0) {
+  free(arg0);
+}
+
+size_t uv_loop_size(void) {
+  return sizeof(uv_loop_t);
+}
+
+int uv_loop_alive(const uv_loop_t* loop) {
+  UV__UNUSED(loop); return 0;
+}
+
+int uv_loop_configure(uv_loop_t* loop, uv_loop_option option, ...) {
+  UV__UNUSED(loop); UV__UNUSED(option); return UV_ENOSYS;
+}
+
+int uv_loop_fork(uv_loop_t* loop) {
+  UV__UNUSED(loop);
+  return UV_ENOSYS;
+}
+
+#define WASI_MAX_IDLE 32
+#define WASI_MAX_TIMER 32
+#define WASI_MAX_ASYNC 32
+typedef struct {
+  uv_idle_t* idle;
+  uv_idle_cb cb;
+  uv_loop_t* loop;
+  int active;
+} wasi_idle_slot;
+
+typedef struct {
+  uv_timer_t* handle;
+  uv_timer_cb cb;
+  uv_loop_t* loop;
+  uint64_t due_ns;
+  uint64_t repeat_ns;
+  int active;
+} wasi_timer_slot;
+
+typedef struct {
+  uv_async_t* handle;
+  uv_async_cb cb;
+  uv_loop_t* loop;
+  int pending;
+} wasi_async_slot;
+
+static wasi_idle_slot wasi_idles[WASI_MAX_IDLE];
+static wasi_timer_slot wasi_timers[WASI_MAX_TIMER];
+static wasi_async_slot wasi_asyncs[WASI_MAX_ASYNC];
+static uv_stream_t* wasi_stdin_stream = NULL;
+static uv_alloc_cb wasi_stdin_alloc = NULL;
+static uv_read_cb wasi_stdin_read = NULL;
+int uv_run(uv_loop_t* arg0, uv_run_mode mode) {
+  UV__UNUSED(mode);
+  uv_loop_t* loop = arg0 ? arg0 : uv_default_loop();
+  int did_work = 0;
+
+  uint64_t now_ns = uv_hrtime();
+
+  for (int i = 0; i < WASI_MAX_IDLE; i++) {
+    if (wasi_idles[i].active && (!wasi_idles[i].loop || wasi_idles[i].loop == loop)
+        && wasi_idles[i].cb) {
+      wasi_idles[i].cb(wasi_idles[i].idle);
+      did_work = 1;
+    }
+  }
+
+  for (int i = 0; i < WASI_MAX_TIMER; i++) {
+    if (wasi_timers[i].active && wasi_timers[i].cb
+        && (!wasi_timers[i].loop || wasi_timers[i].loop == loop)) {
+      if (wasi_timers[i].due_ns <= now_ns) {
+        wasi_timers[i].cb(wasi_timers[i].handle);
+        did_work = 1;
+        if (wasi_timers[i].repeat_ns) {
+          wasi_timers[i].due_ns = now_ns + wasi_timers[i].repeat_ns;
+        } else {
+          wasi_timers[i].active = 0;
+        }
+      }
+    }
+  }
+
+  for (int i = 0; i < WASI_MAX_ASYNC; i++) {
+    if (wasi_asyncs[i].pending && wasi_asyncs[i].cb
+        && (!wasi_asyncs[i].loop || wasi_asyncs[i].loop == loop)) {
+      wasi_asyncs[i].pending = 0;
+      wasi_asyncs[i].cb(wasi_asyncs[i].handle);
+      did_work = 1;
+    }
+  }
+
+  if (wasi_stdin_stream && wasi_stdin_alloc && wasi_stdin_read) {
+    uv_buf_t buf;
+    wasi_stdin_alloc(wasi_stdin_stream, 4096, &buf);
+    if (buf.base && buf.len > 0) {
+      int fd = 0;
+      if (wasi_stdin_stream->io_watcher.fd >= 0) {
+        fd = wasi_stdin_stream->io_watcher.fd;
+      }
+      ssize_t n = read(fd, buf.base, buf.len);
+      if (n > 0) {
+        wasi_stdin_read(wasi_stdin_stream, n, &buf);
+        did_work = 1;
+      } else if (n == 0) {
+        wasi_stdin_read(wasi_stdin_stream, UV_EOF, &buf);
+        did_work = 1;
+      } else if (errno != EAGAIN && errno != EWOULDBLOCK) {
+        wasi_stdin_read(wasi_stdin_stream, -errno, &buf);
+        did_work = 1;
+      }
+    }
+  }
+
+  if (!did_work) {
+    usleep(1000);
+  }
+  return 0;
+}
+void uv_stop(uv_loop_t* arg0) {
+  if (arg0) arg0->stop_flag = 1;
+}
+
+void uv_ref(uv_handle_t* arg0) {
+  UV__UNUSED(arg0);
+}
+
+void uv_unref(uv_handle_t* arg0) {
+  UV__UNUSED(arg0);
+}
+
+int uv_has_ref(const uv_handle_t* arg0) {
+  UV__UNUSED(arg0); return 0;
+}
+
+void uv_update_time(uv_loop_t* arg0) {
+  if (arg0) arg0->time = uv_hrtime() / 1000000ULL;
+}
+
+uint64_t uv_now(const uv_loop_t* arg0) {
+  if (!arg0) return 0;
+  if (arg0->time) return arg0->time;
+  return uv_hrtime() / 1000000ULL;
+}
+
+int uv_backend_fd(const uv_loop_t* arg0) {
+  UV__UNUSED(arg0); return -1;
+}
+
+int uv_backend_timeout(const uv_loop_t* arg0) {
+  UV__UNUSED(arg0); return 0;
+}
+
+int uv_translate_sys_error(int sys_errno) {
+  return sys_errno;
+}
+
+const char* uv_strerror(int err) {
+  UV__UNUSED(err);
+  return NULL;
+}
+
+char* uv_strerror_r(int err, char* buf, size_t buflen) {
+  UV__UNUSED(err);
+  UV__UNUSED(buf);
+  UV__UNUSED(buflen);
+  return NULL;
+}
+
+const char* uv_err_name(int err) {
+  UV__UNUSED(err);
+  return NULL;
+}
+
+char* uv_err_name_r(int err, char* buf, size_t buflen) {
+  UV__UNUSED(err);
+  UV__UNUSED(buf);
+  UV__UNUSED(buflen);
+  return NULL;
+}
+
+int uv_shutdown(uv_shutdown_t* req, uv_stream_t* handle, uv_shutdown_cb cb) {
+  UV__UNUSED(req);
+  UV__UNUSED(handle);
+  UV__UNUSED(cb);
+  return UV_ENOSYS;
+}
+
+size_t uv_handle_size(uv_handle_type type) {
+  switch (type) {
+  #define XX(uc, lc) case UV_##uc: return sizeof(uv_##lc##_t);
+      UV_HANDLE_TYPE_MAP(XX)
+  #undef XX
+      default: return 0;
+    }
+}
+
+uv_handle_type uv_handle_get_type(const uv_handle_t* handle) {
+  UV__UNUSED(handle);
+  return 0;
+}
+
+const char* uv_handle_type_name(uv_handle_type type) {
+  UV__UNUSED(type);
+  return NULL;
+}
+
+void* uv_handle_get_data(const uv_handle_t* handle) {
+  UV__UNUSED(handle);
+  return NULL;
+}
+
+uv_loop_t* uv_handle_get_loop(const uv_handle_t* handle) {
+  UV__UNUSED(handle);
+  return NULL;
+}
+
+void uv_handle_set_data(uv_handle_t* handle, void* data) {
+  UV__UNUSED(handle);
+  UV__UNUSED(data);
+}
+
+size_t uv_req_size(uv_req_type type) {
+  switch (type) {
+  #define XX(uc, lc) case UV_##uc: return sizeof(uv_##lc##_t);
+      UV_REQ_TYPE_MAP(XX)
+  #undef XX
+      default: return 0;
+    }
+}
+
+void* uv_req_get_data(const uv_req_t* req) {
+  UV__UNUSED(req);
+  return NULL;
+}
+
+void uv_req_set_data(uv_req_t* req, void* data) {
+  UV__UNUSED(req);
+  UV__UNUSED(data);
+}
+
+uv_req_type uv_req_get_type(const uv_req_t* req) {
+  UV__UNUSED(req);
+  return 0;
+}
+
+const char* uv_req_type_name(uv_req_type type) {
+  UV__UNUSED(type);
+  return NULL;
+}
+
+int uv_is_active(const uv_handle_t* handle) {
+  UV__UNUSED(handle);
+  return UV_ENOSYS;
+}
+
+void uv_walk(uv_loop_t* loop, uv_walk_cb walk_cb, void* arg) {
+  UV__UNUSED(loop); UV__UNUSED(walk_cb); UV__UNUSED(arg);
+}
+
+void uv_print_all_handles(uv_loop_t* loop, FILE* stream) {
+  UV__UNUSED(loop);
+  UV__UNUSED(stream);
+}
+
+void uv_print_active_handles(uv_loop_t* loop, FILE* stream) {
+  UV__UNUSED(loop);
+  UV__UNUSED(stream);
+}
+
+void uv_close(uv_handle_t* handle, uv_close_cb close_cb) {
+  UV__UNUSED(handle);
+  UV__UNUSED(close_cb);
+}
+
+int uv_send_buffer_size(uv_handle_t* handle, int* value) {
+  UV__UNUSED(handle);
+  UV__UNUSED(value);
+  return UV_ENOSYS;
+}
+
+int uv_recv_buffer_size(uv_handle_t* handle, int* value) {
+  UV__UNUSED(handle);
+  UV__UNUSED(value);
+  return UV_ENOSYS;
+}
+
+int uv_fileno(const uv_handle_t* handle, uv_os_fd_t* fd) {
+  UV__UNUSED(handle);
+  UV__UNUSED(fd);
+  return UV_ENOSYS;
+}
+
+uv_buf_t uv_buf_init(char* base, unsigned int len) {
+  uv_buf_t buf; buf.base = base; buf.len = len; return buf;
+}
+
+int uv_pipe(uv_file fds[2], int read_flags, int write_flags) {
+  UV__UNUSED(fds);
+  UV__UNUSED(read_flags);
+  UV__UNUSED(write_flags);
+  return UV_ENOSYS;
+}
+
+int uv_socketpair(int type, int protocol, uv_os_sock_t socket_vector[2], int flags0, int flags1) {
+  UV__UNUSED(type);
+  UV__UNUSED(protocol);
+  UV__UNUSED(socket_vector);
+  UV__UNUSED(flags0);
+  UV__UNUSED(flags1);
+  return UV_ENOSYS;
+}
+
+size_t uv_stream_get_write_queue_size(const uv_stream_t* stream) {
+  UV__UNUSED(stream);
+  return 0;
+}
+
+int uv_listen(uv_stream_t* stream, int backlog, uv_connection_cb cb) {
+  UV__UNUSED(stream);
+  UV__UNUSED(backlog);
+  UV__UNUSED(cb);
+  // Pretend listen succeeded; no real inbound connections in WASI demo.
+  return 0;
+}
+
+int uv_accept(uv_stream_t* server, uv_stream_t* client) {
+  UV__UNUSED(server);
+  UV__UNUSED(client);
+  return 0;
+}
+
+int uv_read_start(uv_stream_t* arg0, uv_alloc_cb alloc_cb, uv_read_cb read_cb) {
+  wasi_stdin_stream = arg0;
+  wasi_stdin_alloc = alloc_cb;
+  wasi_stdin_read = read_cb;
+  return 0;
+}
+
+int uv_read_stop(uv_stream_t* arg0) {
+  UV__UNUSED(arg0);
+  wasi_stdin_stream = NULL;
+  wasi_stdin_alloc = NULL;
+  wasi_stdin_read = NULL;
+  return 0;
+}
+
+int uv_write(uv_write_t* req, uv_stream_t* handle, const uv_buf_t bufs[], unsigned int nbufs, uv_write_cb cb) {
+  int fd = 1;
+  if (handle && handle->io_watcher.fd >= 0) {
+    fd = handle->io_watcher.fd;
+  }
+  ssize_t written = 0;
+  for (unsigned int i = 0; i < nbufs; i++) {
+    if (bufs[i].base && bufs[i].len > 0) {
+      ssize_t n = write(fd, bufs[i].base, bufs[i].len);
+      if (n > 0) written += n;
+    }
+  }
+  if (cb) cb(req, written < 0 ? -1 : 0);
+  return 0;
+}
+
+int uv_write2(uv_write_t* req, uv_stream_t* handle, const uv_buf_t bufs[], unsigned int nbufs, uv_stream_t* send_handle, uv_write_cb cb) {
+  UV__UNUSED(send_handle);
+  return uv_write(req, handle, bufs, nbufs, cb);
+}
+
+int uv_try_write(uv_stream_t* handle, const uv_buf_t bufs[], unsigned int nbufs) {
+  UV__UNUSED(handle);
+  for (unsigned int i = 0; i < nbufs; i++) {
+    if (bufs[i].base && bufs[i].len > 0) {
+      write(1, bufs[i].base, bufs[i].len);
+    }
+  }
+  return 0;
+}
+
+int uv_try_write2(uv_stream_t* handle, const uv_buf_t bufs[], unsigned int nbufs, uv_stream_t* send_handle) {
+  UV__UNUSED(send_handle);
+  return uv_try_write(handle, bufs, nbufs);
+}
+
+int uv_is_readable(const uv_stream_t* handle) {
+  UV__UNUSED(handle);
+  return UV_ENOSYS;
+}
+
+int uv_is_writable(const uv_stream_t* handle) {
+  UV__UNUSED(handle);
+  return UV_ENOSYS;
+}
+
+int uv_stream_set_blocking(uv_stream_t* handle, int blocking) {
+  UV__UNUSED(handle);
+  UV__UNUSED(blocking);
+  return UV_ENOSYS;
+}
+
+int uv_is_closing(const uv_handle_t* handle) {
+  UV__UNUSED(handle);
+  return UV_ENOSYS;
+}
+
+int uv_tcp_init(uv_loop_t* arg0, uv_tcp_t* handle) {
+  UV__UNUSED(arg0);
+  UV__UNUSED(handle);
+  return UV_ENOSYS;
+}
+
+int uv_tcp_init_ex(uv_loop_t* arg0, uv_tcp_t* handle, unsigned int flags) {
+  UV__UNUSED(arg0);
+  UV__UNUSED(handle);
+  UV__UNUSED(flags);
+  return UV_ENOSYS;
+}
+
+int uv_tcp_open(uv_tcp_t* handle, uv_os_sock_t sock) {
+  UV__UNUSED(handle);
+  UV__UNUSED(sock);
+  return UV_ENOSYS;
+}
+
+int uv_tcp_nodelay(uv_tcp_t* handle, int enable) {
+  UV__UNUSED(handle);
+  UV__UNUSED(enable);
+  return UV_ENOSYS;
+}
+
+int uv_tcp_keepalive(uv_tcp_t* handle, int enable, unsigned int delay) {
+  UV__UNUSED(handle);
+  UV__UNUSED(enable);
+  UV__UNUSED(delay);
+  return UV_ENOSYS;
+}
+
+int uv_tcp_simultaneous_accepts(uv_tcp_t* handle, int enable) {
+  UV__UNUSED(handle);
+  UV__UNUSED(enable);
+  return UV_ENOSYS;
+}
+
+int uv_tcp_bind(uv_tcp_t* handle, const struct sockaddr* addr, unsigned int flags) {
+  UV__UNUSED(handle);
+  UV__UNUSED(addr);
+  UV__UNUSED(flags);
+  return UV_ENOSYS;
+}
+
+int uv_tcp_getsockname(const uv_tcp_t* handle, struct sockaddr* name, int* namelen) {
+  UV__UNUSED(handle);
+  UV__UNUSED(name);
+  UV__UNUSED(namelen);
+  return UV_ENOSYS;
+}
+
+int uv_tcp_getpeername(const uv_tcp_t* handle, struct sockaddr* name, int* namelen) {
+  UV__UNUSED(handle);
+  UV__UNUSED(name);
+  UV__UNUSED(namelen);
+  return UV_ENOSYS;
+}
+
+int uv_tcp_close_reset(uv_tcp_t* handle, uv_close_cb close_cb) {
+  UV__UNUSED(handle);
+  UV__UNUSED(close_cb);
+  return UV_ENOSYS;
+}
+
+int uv_tcp_connect(uv_connect_t* req, uv_tcp_t* handle, const struct sockaddr* addr, uv_connect_cb cb) {
+  UV__UNUSED(req);
+  UV__UNUSED(handle);
+  UV__UNUSED(addr);
+  UV__UNUSED(cb);
+  return UV_ENOSYS;
+}
+
+int uv_udp_init(uv_loop_t* arg0, uv_udp_t* handle) {
+  UV__UNUSED(arg0);
+  UV__UNUSED(handle);
+  return UV_ENOSYS;
+}
+
+int uv_udp_init_ex(uv_loop_t* arg0, uv_udp_t* handle, unsigned int flags) {
+  UV__UNUSED(arg0);
+  UV__UNUSED(handle);
+  UV__UNUSED(flags);
+  return UV_ENOSYS;
+}
+
+int uv_udp_open(uv_udp_t* handle, uv_os_sock_t sock) {
+  UV__UNUSED(handle);
+  UV__UNUSED(sock);
+  return UV_ENOSYS;
+}
+
+int uv_udp_bind(uv_udp_t* handle, const struct sockaddr* addr, unsigned int flags) {
+  UV__UNUSED(handle);
+  UV__UNUSED(addr);
+  UV__UNUSED(flags);
+  return UV_ENOSYS;
+}
+
+int uv_udp_connect(uv_udp_t* handle, const struct sockaddr* addr) {
+  UV__UNUSED(handle);
+  UV__UNUSED(addr);
+  return UV_ENOSYS;
+}
+
+int uv_udp_getpeername(const uv_udp_t* handle, struct sockaddr* name, int* namelen) {
+  UV__UNUSED(handle);
+  UV__UNUSED(name);
+  UV__UNUSED(namelen);
+  return UV_ENOSYS;
+}
+
+int uv_udp_getsockname(const uv_udp_t* handle, struct sockaddr* name, int* namelen) {
+  UV__UNUSED(handle);
+  UV__UNUSED(name);
+  UV__UNUSED(namelen);
+  return UV_ENOSYS;
+}
+
+int uv_udp_set_membership(uv_udp_t* handle, const char* multicast_addr, const char* interface_addr, uv_membership membership) {
+  UV__UNUSED(handle);
+  UV__UNUSED(multicast_addr);
+  UV__UNUSED(interface_addr);
+  UV__UNUSED(membership);
+  return UV_ENOSYS;
+}
+
+int uv_udp_set_source_membership(uv_udp_t* handle, const char* multicast_addr, const char* interface_addr, const char* source_addr, uv_membership membership) {
+  UV__UNUSED(handle);
+  UV__UNUSED(multicast_addr);
+  UV__UNUSED(interface_addr);
+  UV__UNUSED(source_addr);
+  UV__UNUSED(membership);
+  return UV_ENOSYS;
+}
+
+int uv_udp_set_multicast_loop(uv_udp_t* handle, int on) {
+  UV__UNUSED(handle);
+  UV__UNUSED(on);
+  return UV_ENOSYS;
+}
+
+int uv_udp_set_multicast_ttl(uv_udp_t* handle, int ttl) {
+  UV__UNUSED(handle);
+  UV__UNUSED(ttl);
+  return UV_ENOSYS;
+}
+
+int uv_udp_set_multicast_interface(uv_udp_t* handle, const char* interface_addr) {
+  UV__UNUSED(handle);
+  UV__UNUSED(interface_addr);
+  return UV_ENOSYS;
+}
+
+int uv_udp_set_broadcast(uv_udp_t* handle, int on) {
+  UV__UNUSED(handle);
+  UV__UNUSED(on);
+  return UV_ENOSYS;
+}
+
+int uv_udp_set_ttl(uv_udp_t* handle, int ttl) {
+  UV__UNUSED(handle);
+  UV__UNUSED(ttl);
+  return UV_ENOSYS;
+}
+
+int uv_udp_send(uv_udp_send_t* req, uv_udp_t* handle, const uv_buf_t bufs[], unsigned int nbufs, const struct sockaddr* addr, uv_udp_send_cb send_cb) {
+  UV__UNUSED(req);
+  UV__UNUSED(handle);
+  UV__UNUSED(bufs);
+  UV__UNUSED(nbufs);
+  UV__UNUSED(addr);
+  UV__UNUSED(send_cb);
+  return UV_ENOSYS;
+}
+
+int uv_udp_try_send(uv_udp_t* handle, const uv_buf_t bufs[], unsigned int nbufs, const struct sockaddr* addr) {
+  UV__UNUSED(handle);
+  UV__UNUSED(bufs);
+  UV__UNUSED(nbufs);
+  UV__UNUSED(addr);
+  return UV_ENOSYS;
+}
+
+int uv_udp_try_send2(uv_udp_t* handle, unsigned int count, uv_buf_t* bufs[/*count*/], unsigned int nbufs[/*count*/], struct sockaddr* addrs[/*count*/], unsigned int flags) {
+  UV__UNUSED(handle);
+  UV__UNUSED(count);
+  UV__UNUSED(bufs);
+  UV__UNUSED(nbufs);
+  UV__UNUSED(addrs);
+  UV__UNUSED(flags);
+  return UV_ENOSYS;
+}
+
+int uv_udp_recv_start(uv_udp_t* handle, uv_alloc_cb alloc_cb, uv_udp_recv_cb recv_cb) {
+  UV__UNUSED(handle);
+  UV__UNUSED(alloc_cb);
+  UV__UNUSED(recv_cb);
+  return UV_ENOSYS;
+}
+
+int uv_udp_using_recvmmsg(const uv_udp_t* handle) {
+  UV__UNUSED(handle);
+  return UV_ENOSYS;
+}
+
+int uv_udp_recv_stop(uv_udp_t* handle) {
+  UV__UNUSED(handle);
+  return UV_ENOSYS;
+}
+
+size_t uv_udp_get_send_queue_size(const uv_udp_t* handle) {
+  UV__UNUSED(handle);
+  return 0;
+}
+
+size_t uv_udp_get_send_queue_count(const uv_udp_t* handle) {
+  UV__UNUSED(handle);
+  return 0;
+}
+
+int uv_tty_init(uv_loop_t* loop, uv_tty_t* tty, uv_file fd, int readable) {
+  UV__UNUSED(readable);
+  const char *term = getenv("TERM");
+  if (!term || !*term) {
+    return UV_ENOSYS;
+  }
+  if (tty) {
+    memset(tty, 0, sizeof(*tty));
+    tty->type = UV_TTY;
+    tty->loop = loop;
+    tty->io_watcher.fd = fd;
+  }
+  return 0;
+}
+
+int uv_tty_set_mode(uv_tty_t* tty, uv_tty_mode_t mode) {
+  UV__UNUSED(tty);
+  UV__UNUSED(mode);
+  return 0;  // Host handles raw mode
+}
+
+int uv_tty_reset_mode(void) {
+  return 0;
+}
+
+int uv_tty_get_winsize(uv_tty_t* tty, int* width, int* height) {
+  UV__UNUSED(tty);
+  const char *cols = getenv("COLUMNS");
+  const char *lines = getenv("LINES");
+  *width = cols ? atoi(cols) : 80;
+  *height = lines ? atoi(lines) : 24;
+  return (*width > 0 && *height > 0) ? 0 : UV_ENOSYS;
+}
+
+void uv_tty_set_vterm_state(uv_tty_vtermstate_t state) {
+  UV__UNUSED(state);
+}
+
+int uv_tty_get_vterm_state(uv_tty_vtermstate_t* state) {
+  UV__UNUSED(state);
+  return UV_ENOSYS;
+}
+
+uv_handle_type uv_guess_handle(uv_file file) {
+  // Check if TERM is set for TUI mode detection
+  if (file >= 0 && file <= 2) {
+    const char *term = getenv("TERM");
+    if (term && *term) {
+      return UV_TTY;
+    }
+    return UV_NAMED_PIPE;
+  }
+  return UV_FILE;
+}
+
+int uv_pipe_init(uv_loop_t* arg0, uv_pipe_t* handle, int ipc) {
+  UV__UNUSED(ipc);
+  if (handle) {
+    memset(handle, 0, sizeof(*handle));
+    handle->type = UV_NAMED_PIPE;
+    handle->loop = arg0;
+    handle->io_watcher.fd = -1;
+  }
+  return 0;  // no-op success on WASI
+}
+
+int uv_pipe_open(uv_pipe_t* arg0, uv_file file) {
+  if (arg0) {
+    arg0->io_watcher.fd = file;
+  }
+  return 0;
+}
+
+int uv_pipe_bind(uv_pipe_t* handle, const char* name) {
+  UV__UNUSED(handle);
+  UV__UNUSED(name);
+  return 0;
+}
+
+int uv_pipe_bind2(uv_pipe_t* handle, const char* name, size_t namelen, unsigned int flags) {
+  UV__UNUSED(handle);
+  UV__UNUSED(name);
+  UV__UNUSED(namelen);
+  UV__UNUSED(flags);
+  return 0;
+}
+
+void uv_pipe_connect(uv_connect_t* req, uv_pipe_t* handle, const char* name, uv_connect_cb cb) {
+  UV__UNUSED(req);
+  UV__UNUSED(handle);
+  UV__UNUSED(name);
+  if (cb) cb(req, 0);
+}
+
+int uv_pipe_connect2(uv_connect_t* req, uv_pipe_t* handle, const char* name, size_t namelen, unsigned int flags, uv_connect_cb cb) {
+  UV__UNUSED(req);
+  UV__UNUSED(handle);
+  UV__UNUSED(name);
+  UV__UNUSED(namelen);
+  UV__UNUSED(flags);
+  if (cb) cb(req, 0);
+  return 0;
+}
+
+int uv_pipe_getsockname(const uv_pipe_t* handle, char* buffer, size_t* size) {
+  UV__UNUSED(handle);
+  UV__UNUSED(buffer);
+  UV__UNUSED(size);
+  return UV_ENOSYS;
+}
+
+int uv_pipe_getpeername(const uv_pipe_t* handle, char* buffer, size_t* size) {
+  UV__UNUSED(handle);
+  UV__UNUSED(buffer);
+  UV__UNUSED(size);
+  return UV_ENOSYS;
+}
+
+void uv_pipe_pending_instances(uv_pipe_t* handle, int count) {
+  UV__UNUSED(handle);
+  UV__UNUSED(count);
+}
+
+int uv_pipe_pending_count(uv_pipe_t* handle) {
+  UV__UNUSED(handle);
+  return 0;
+}
+
+uv_handle_type uv_pipe_pending_type(uv_pipe_t* handle) {
+  UV__UNUSED(handle);
+  return 0;
+}
+
+int uv_pipe_chmod(uv_pipe_t* handle, int flags) {
+  UV__UNUSED(handle);
+  UV__UNUSED(flags);
+  return UV_ENOSYS;
+}
+
+int uv_poll_init(uv_loop_t* loop, uv_poll_t* handle, int fd) {
+  UV__UNUSED(loop);
+  UV__UNUSED(handle);
+  UV__UNUSED(fd);
+  return UV_ENOSYS;
+}
+
+int uv_poll_init_socket(uv_loop_t* loop, uv_poll_t* handle, uv_os_sock_t socket) {
+  UV__UNUSED(loop);
+  UV__UNUSED(handle);
+  UV__UNUSED(socket);
+  return UV_ENOSYS;
+}
+
+int uv_poll_start(uv_poll_t* handle, int events, uv_poll_cb cb) {
+  UV__UNUSED(handle);
+  UV__UNUSED(events);
+  UV__UNUSED(cb);
+  return UV_ENOSYS;
+}
+
+int uv_poll_stop(uv_poll_t* handle) {
+  UV__UNUSED(handle);
+  return UV_ENOSYS;
+}
+
+int uv_prepare_init(uv_loop_t* arg0, uv_prepare_t* prepare) {
+  UV__UNUSED(arg0);
+  UV__UNUSED(prepare);
+  return UV_ENOSYS;
+}
+
+int uv_prepare_start(uv_prepare_t* prepare, uv_prepare_cb cb) {
+  UV__UNUSED(prepare);
+  UV__UNUSED(cb);
+  return UV_ENOSYS;
+}
+
+int uv_prepare_stop(uv_prepare_t* prepare) {
+  UV__UNUSED(prepare);
+  return UV_ENOSYS;
+}
+
+int uv_check_init(uv_loop_t* arg0, uv_check_t* check) {
+  UV__UNUSED(arg0);
+  UV__UNUSED(check);
+  return UV_ENOSYS;
+}
+
+int uv_check_start(uv_check_t* check, uv_check_cb cb) {
+  UV__UNUSED(check);
+  UV__UNUSED(cb);
+  return UV_ENOSYS;
+}
+
+int uv_check_stop(uv_check_t* check) {
+  UV__UNUSED(check);
+  return UV_ENOSYS;
+}
+
+int uv_idle_init(uv_loop_t* arg0, uv_idle_t* idle) {
+  if (!idle) return UV_EINVAL;
+  memset(idle, 0, sizeof(*idle));
+  idle->loop = arg0 ? arg0 : uv_default_loop();
+  idle->type = UV_IDLE;
+  return 0;
+}
+
+int uv_idle_start(uv_idle_t* idle, uv_idle_cb cb) {
+  if (!idle || !cb) return UV_EINVAL;
+  for (int i = 0; i < WASI_MAX_IDLE; i++) {
+    if (!wasi_idles[i].active || wasi_idles[i].idle == idle) {
+      wasi_idles[i].idle = idle;
+      wasi_idles[i].cb = cb;
+      wasi_idles[i].loop = idle->loop;
+      wasi_idles[i].active = 1;
+      return 0;
+    }
+  }
+  return UV_ENOMEM;
+}
+
+int uv_idle_stop(uv_idle_t* idle) {
+  if (!idle) return UV_EINVAL;
+  for (int i = 0; i < WASI_MAX_IDLE; i++) {
+    if (wasi_idles[i].idle == idle) {
+      wasi_idles[i].active = 0;
+    }
+  }
+  return 0;
+}
+
+int uv_async_init(uv_loop_t* arg0, uv_async_t* async, uv_async_cb async_cb) {
+  if (!async) return UV_EINVAL;
+  memset(async, 0, sizeof(*async));
+  async->loop = arg0 ? arg0 : uv_default_loop();
+  async->async_cb = async_cb;
+  for (int i = 0; i < WASI_MAX_ASYNC; i++) {
+    if (!wasi_asyncs[i].handle || wasi_asyncs[i].handle == async) {
+      wasi_asyncs[i].handle = async;
+      wasi_asyncs[i].cb = async_cb;
+      wasi_asyncs[i].loop = async->loop;
+      wasi_asyncs[i].pending = 0;
+      return 0;
+    }
+  }
+  return UV_ENOMEM;
+}
+
+int uv_async_send(uv_async_t* async) {
+  if (!async) return UV_EINVAL;
+  for (int i = 0; i < WASI_MAX_ASYNC; i++) {
+    if (wasi_asyncs[i].handle == async) {
+      wasi_asyncs[i].pending = 1;
+      return 0;
+    }
+  }
+  return UV_EINVAL;
+}
+
+int uv_timer_init(uv_loop_t* arg0, uv_timer_t* handle) {
+  if (!handle) return UV_EINVAL;
+  memset(handle, 0, sizeof(*handle));
+  handle->loop = arg0 ? arg0 : uv_default_loop();
+  handle->type = UV_TIMER;
+  return 0;
+}
+
+int uv_timer_start(uv_timer_t* handle, uv_timer_cb cb, uint64_t timeout, uint64_t repeat) {
+  if (!handle || !cb) return UV_EINVAL;
+  uint64_t now = uv_hrtime();
+  for (int i = 0; i < WASI_MAX_TIMER; i++) {
+    if (!wasi_timers[i].active || wasi_timers[i].handle == handle) {
+      wasi_timers[i].handle = handle;
+      wasi_timers[i].cb = cb;
+      wasi_timers[i].loop = handle->loop;
+      wasi_timers[i].due_ns = now + (timeout * 1000000ULL);
+      wasi_timers[i].repeat_ns = repeat * 1000000ULL;
+      wasi_timers[i].active = 1;
+      return 0;
+    }
+  }
+  return UV_ENOMEM;
+}
+
+int uv_timer_stop(uv_timer_t* handle) {
+  if (!handle) return UV_EINVAL;
+  for (int i = 0; i < WASI_MAX_TIMER; i++) {
+    if (wasi_timers[i].handle == handle) {
+      wasi_timers[i].active = 0;
+    }
+  }
+  return 0;
+}
+
+int uv_timer_again(uv_timer_t* handle) {
+  if (!handle) return UV_EINVAL;
+  for (int i = 0; i < WASI_MAX_TIMER; i++) {
+    if (wasi_timers[i].handle == handle && wasi_timers[i].repeat_ns > 0) {
+      wasi_timers[i].due_ns = uv_hrtime() + wasi_timers[i].repeat_ns;
+      wasi_timers[i].active = 1;
+      return 0;
+    }
+  }
+  return UV_EINVAL;
+}
+
+void uv_timer_set_repeat(uv_timer_t* handle, uint64_t repeat) {
+  if (!handle) return;
+  for (int i = 0; i < WASI_MAX_TIMER; i++) {
+    if (wasi_timers[i].handle == handle) {
+      wasi_timers[i].repeat_ns = repeat * 1000000ULL;
+    }
+  }
+}
+
+uint64_t uv_timer_get_repeat(const uv_timer_t* handle) {
+  if (!handle) return 0;
+  for (int i = 0; i < WASI_MAX_TIMER; i++) {
+    if (wasi_timers[i].handle == handle) {
+      return wasi_timers[i].repeat_ns / 1000000ULL;
+    }
+  }
+  return 0;
+}
+
+uint64_t uv_timer_get_due_in(const uv_timer_t* handle) {
+  if (!handle) return 0;
+  uint64_t now = uv_hrtime();
+  for (int i = 0; i < WASI_MAX_TIMER; i++) {
+    if (wasi_timers[i].handle == handle && wasi_timers[i].active) {
+      if (wasi_timers[i].due_ns <= now) return 0;
+      return (wasi_timers[i].due_ns - now) / 1000000ULL;
+    }
+  }
+  return 0;
+}
+
+int uv_getaddrinfo(uv_loop_t* loop, uv_getaddrinfo_t* req, uv_getaddrinfo_cb getaddrinfo_cb, const char* node, const char* service, const struct addrinfo* hints) {
+  UV__UNUSED(loop);
+  UV__UNUSED(req);
+  UV__UNUSED(getaddrinfo_cb);
+  UV__UNUSED(node);
+  UV__UNUSED(service);
+  UV__UNUSED(hints);
+  return UV_ENOSYS;
+}
+
+void uv_freeaddrinfo(struct addrinfo* ai) {
+  UV__UNUSED(ai);
+}
+
+int uv_getnameinfo(uv_loop_t* loop, uv_getnameinfo_t* req, uv_getnameinfo_cb getnameinfo_cb, const struct sockaddr* addr, int flags) {
+  UV__UNUSED(loop);
+  UV__UNUSED(req);
+  UV__UNUSED(getnameinfo_cb);
+  UV__UNUSED(addr);
+  UV__UNUSED(flags);
+  return UV_ENOSYS;
+}
+
+int uv_spawn(uv_loop_t* loop, uv_process_t* handle, const uv_process_options_t* options) {
+  UV__UNUSED(loop);
+  UV__UNUSED(handle);
+  UV__UNUSED(options);
+  return UV_ENOSYS;
+}
+
+int uv_process_kill(uv_process_t* arg0, int signum) {
+  UV__UNUSED(arg0);
+  UV__UNUSED(signum);
+  return UV_ENOSYS;
+}
+
+int uv_kill(int pid, int signum) {
+  UV__UNUSED(pid);
+  UV__UNUSED(signum);
+  return UV_ENOSYS;
+}
+
+uv_pid_t uv_process_get_pid(const uv_process_t* arg0) {
+  UV__UNUSED(arg0);
+  return UV_ENOSYS;
+}
+
+int uv_queue_work(uv_loop_t* loop, uv_work_t* req, uv_work_cb work_cb, uv_after_work_cb after_work_cb) {
+  UV__UNUSED(loop); if (req == NULL || work_cb == NULL || after_work_cb == NULL) return UV_EINVAL; work_cb(req); after_work_cb(req, 0); return 0;
+}
+
+int uv_cancel(uv_req_t* req) {
+  UV__UNUSED(req);
+  return UV_ENOSYS;
+}
+
+char** uv_setup_args(int argc, char** argv) {
+  UV__UNUSED(argc);
+  UV__UNUSED(argv);
+  return NULL;
+}
+
+int uv_get_process_title(char* buffer, size_t size) {
+  UV__UNUSED(buffer);
+  UV__UNUSED(size);
+  return UV_ENOSYS;
+}
+
+int uv_set_process_title(const char* title) {
+  UV__UNUSED(title);
+  return UV_ENOSYS;
+}
+
+int uv_resident_set_memory(size_t* rss) {
+  UV__UNUSED(rss);
+  return UV_ENOSYS;
+}
+
+int uv_uptime(double* uptime) {
+  UV__UNUSED(uptime);
+  return UV_ENOSYS;
+}
+
+uv_os_fd_t uv_get_osfhandle(int fd) {
+  UV__UNUSED(fd);
+  return UV_ENOSYS;
+}
+
+int uv_open_osfhandle(uv_os_fd_t os_fd) {
+  UV__UNUSED(os_fd);
+  return UV_ENOSYS;
+}
+
+int uv_getrusage(uv_rusage_t* rusage) {
+  UV__UNUSED(rusage);
+  return UV_ENOSYS;
+}
+
+int uv_getrusage_thread(uv_rusage_t* rusage) {
+  UV__UNUSED(rusage);
+  return UV_ENOSYS;
+}
+
+int uv_os_homedir(char* buffer, size_t* size) {
+  UV__UNUSED(buffer);
+  UV__UNUSED(size);
+  return UV_ENOSYS;
+}
+
+int uv_os_tmpdir(char* buffer, size_t* size) {
+  UV__UNUSED(buffer);
+  UV__UNUSED(size);
+  return UV_ENOSYS;
+}
+
+int uv_os_get_passwd(uv_passwd_t* pwd) {
+  UV__UNUSED(pwd);
+  return UV_ENOSYS;
+}
+
+void uv_os_free_passwd(uv_passwd_t* pwd) {
+  UV__UNUSED(pwd);
+}
+
+int uv_os_get_passwd2(uv_passwd_t* pwd, uv_uid_t uid) {
+  UV__UNUSED(pwd);
+  UV__UNUSED(uid);
+  return UV_ENOSYS;
+}
+
+int uv_os_get_group(uv_group_t* grp, uv_uid_t gid) {
+  UV__UNUSED(grp);
+  UV__UNUSED(gid);
+  return UV_ENOSYS;
+}
+
+void uv_os_free_group(uv_group_t* grp) {
+  UV__UNUSED(grp);
+}
+
+uv_pid_t uv_os_getpid(void) {
+  return UV_ENOSYS;
+}
+
+uv_pid_t uv_os_getppid(void) {
+  return UV_ENOSYS;
+}
+
+int uv_os_getpriority(uv_pid_t pid, int* priority) {
+  UV__UNUSED(pid);
+  UV__UNUSED(priority);
+  return UV_ENOSYS;
+}
+
+int uv_os_setpriority(uv_pid_t pid, int priority) {
+  UV__UNUSED(pid);
+  UV__UNUSED(priority);
+  return UV_ENOSYS;
+}
+
+int uv_thread_getpriority(uv_thread_t tid, int* priority) {
+  UV__UNUSED(tid);
+  UV__UNUSED(priority);
+  return UV_ENOSYS;
+}
+
+int uv_thread_setpriority(uv_thread_t tid, int priority) {
+  UV__UNUSED(tid);
+  UV__UNUSED(priority);
+  return UV_ENOSYS;
+}
+
+unsigned int uv_available_parallelism(void) {
+  return 0;
+}
+
+int uv_cpu_info(uv_cpu_info_t** cpu_infos, int* count) {
+  UV__UNUSED(cpu_infos);
+  UV__UNUSED(count);
+  return UV_ENOSYS;
+}
+
+void uv_free_cpu_info(uv_cpu_info_t* cpu_infos, int count) {
+  UV__UNUSED(cpu_infos);
+  UV__UNUSED(count);
+}
+
+int uv_cpumask_size(void) {
+  return UV_ENOSYS;
+}
+
+int uv_interface_addresses(uv_interface_address_t** addresses, int* count) {
+  UV__UNUSED(addresses);
+  UV__UNUSED(count);
+  return UV_ENOSYS;
+}
+
+void uv_free_interface_addresses(uv_interface_address_t* addresses, int count) {
+  UV__UNUSED(addresses);
+  UV__UNUSED(count);
+}
+
+int uv_os_environ(uv_env_item_t** envitems, int* count) {
+  UV__UNUSED(envitems);
+  UV__UNUSED(count);
+  return UV_ENOSYS;
+}
+
+void uv_os_free_environ(uv_env_item_t* envitems, int count) {
+  UV__UNUSED(envitems);
+  UV__UNUSED(count);
+}
+
+int uv_os_getenv(const char* name, char* buffer, size_t* size) {
+  UV__UNUSED(name);
+  UV__UNUSED(buffer);
+  UV__UNUSED(size);
+  return UV_ENOSYS;
+}
+
+int uv_os_setenv(const char* name, const char* value) {
+  UV__UNUSED(name);
+  UV__UNUSED(value);
+  return UV_ENOSYS;
+}
+
+int uv_os_unsetenv(const char* name) {
+  UV__UNUSED(name);
+  return UV_ENOSYS;
+}
+
+int uv_os_gethostname(char* buffer, size_t* size) {
+  UV__UNUSED(buffer);
+  UV__UNUSED(size);
+  return UV_ENOSYS;
+}
+
+int uv_os_uname(uv_utsname_t* buffer) {
+  UV__UNUSED(buffer);
+  return UV_ENOSYS;
+}
+
+int uv_metrics_info(uv_loop_t* loop, uv_metrics_t* metrics) {
+  UV__UNUSED(loop);
+  UV__UNUSED(metrics);
+  return UV_ENOSYS;
+}
+
+uint64_t uv_metrics_idle_time(uv_loop_t* loop) {
+  UV__UNUSED(loop);
+  return 0;
+}
+
+uv_fs_type uv_fs_get_type(const uv_fs_t* arg0) {
+  UV__UNUSED(arg0);
+  return 0;
+}
+
+ssize_t uv_fs_get_result(const uv_fs_t* arg0) {
+  UV__UNUSED(arg0);
+  return 0;
+}
+
+int uv_fs_get_system_error(const uv_fs_t* arg0) {
+  UV__UNUSED(arg0);
+  return UV_ENOSYS;
+}
+
+void* uv_fs_get_ptr(const uv_fs_t* arg0) {
+  UV__UNUSED(arg0);
+  return NULL;
+}
+
+const char* uv_fs_get_path(const uv_fs_t* arg0) {
+  UV__UNUSED(arg0);
+  return NULL;
+}
+
+uv_stat_t* uv_fs_get_statbuf(uv_fs_t* arg0) {
+  return arg0 ? &arg0->statbuf : NULL;
+}
+
+static void wasi_fs_req_reset(uv_fs_t* req, uv_loop_t* loop, uv_fs_type type, const char* path, uv_fs_cb cb) {
+  if (!req) return;
+  req->fs_type = type;
+  req->loop = loop ? loop : uv_default_loop();
+  req->cb = cb;
+  req->path = path;
+  req->ptr = NULL;
+  req->result = 0;
+  memset(&req->statbuf, 0, sizeof(req->statbuf));
+}
+
+static void wasi_stat_to_uv(const struct stat* in, uv_stat_t* out) {
+  if (!in || !out) return;
+  out->st_dev = in->st_dev;
+  out->st_mode = in->st_mode;
+  out->st_nlink = in->st_nlink;
+  out->st_uid = in->st_uid;
+  out->st_gid = in->st_gid;
+  out->st_rdev = in->st_rdev;
+  out->st_ino = in->st_ino;
+  out->st_size = in->st_size;
+  out->st_blksize = in->st_blksize;
+  out->st_blocks = in->st_blocks;
+  out->st_flags = 0;
+  out->st_gen = 0;
+  out->st_atim.tv_sec = in->st_atim.tv_sec;
+  out->st_atim.tv_nsec = in->st_atim.tv_nsec;
+  out->st_mtim.tv_sec = in->st_mtim.tv_sec;
+  out->st_mtim.tv_nsec = in->st_mtim.tv_nsec;
+  out->st_ctim.tv_sec = in->st_ctim.tv_sec;
+  out->st_ctim.tv_nsec = in->st_ctim.tv_nsec;
+  out->st_birthtim = out->st_ctim;
+}
+
+void uv_fs_req_cleanup(uv_fs_t* req) {
+  if (!req) return;
+  req->cb = NULL;
+  req->path = NULL;
+  req->ptr = NULL;
+}
+
+int uv_fs_close(uv_loop_t* loop, uv_fs_t* req, uv_file file, uv_fs_cb cb) {
+  wasi_fs_req_reset(req, loop, UV_FS_CLOSE, NULL, cb);
+  int rc = close(file);
+  req->result = (rc == 0) ? 0 : -errno;
+  if (cb) cb(req);
+  return cb ? 0 : (int)req->result;
+}
+
+int uv_fs_open(uv_loop_t* loop, uv_fs_t* req, const char* path, int flags, int mode, uv_fs_cb cb) {
+  wasi_fs_req_reset(req, loop, UV_FS_OPEN, path, cb);
+  int fd = open(path, flags, mode);
+  req->result = (fd >= 0) ? fd : -errno;
+  if (cb) cb(req);
+  return cb ? 0 : (int)req->result;
+}
+
+int uv_fs_read(uv_loop_t* loop, uv_fs_t* req, uv_file file, const uv_buf_t bufs[], unsigned int nbufs, int64_t offset, uv_fs_cb cb) {
+  wasi_fs_req_reset(req, loop, UV_FS_READ, NULL, cb);
+  ssize_t total = 0;
+  int64_t pos = offset;
+  for (unsigned int i = 0; i < nbufs; i++) {
+    const uv_buf_t* b = &bufs[i];
+    if (!b->base || b->len == 0) continue;
+    ssize_t n = (offset < 0) ? read(file, b->base, b->len)
+                             : pread(file, b->base, b->len, pos);
+    if (n < 0) {
+      total = -errno;
+      break;
+    }
+    total += n;
+    if (offset >= 0) pos += n;
+    if (n == 0 || (offset < 0 && (size_t)n < b->len)) {
+      break;
+    }
+  }
+  req->result = total;
+  if (cb) cb(req);
+  return cb ? 0 : (int)req->result;
+}
+
+int uv_fs_unlink(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_fs_cb cb) {
+  wasi_fs_req_reset(req, loop, UV_FS_UNLINK, path, cb);
+  int rc = unlink(path);
+  req->result = (rc == 0) ? 0 : -errno;
+  if (cb) cb(req);
+  return cb ? 0 : (int)req->result;
+}
+
+int uv_fs_write(uv_loop_t* loop, uv_fs_t* req, uv_file file, const uv_buf_t bufs[], unsigned int nbufs, int64_t offset, uv_fs_cb cb) {
+  wasi_fs_req_reset(req, loop, UV_FS_WRITE, NULL, cb);
+  ssize_t total = 0;
+  int64_t pos = offset;
+  for (unsigned int i = 0; i < nbufs; i++) {
+    const uv_buf_t* b = &bufs[i];
+    if (!b->base || b->len == 0) continue;
+    ssize_t n = -1;
+    if (offset < 0) {
+      n = write(file, b->base, b->len);
+    } else {
+      n = pwrite(file, b->base, b->len, pos);
+      if (n < 0 && (errno == ESPIPE || errno == EBADF)) {
+        n = write(file, b->base, b->len);
+      }
+    }
+    if (n < 0) {
+      total = -errno;
+      break;
+    }
+    total += n;
+    if (offset >= 0) pos += n;
+    if (n == 0 || (offset < 0 && (size_t)n < b->len)) {
+      break;
+    }
+  }
+  req->result = total;
+  if (cb) cb(req);
+  return cb ? 0 : (int)req->result;
+}
+
+int uv_fs_copyfile(uv_loop_t* loop, uv_fs_t* req, const char* path, const char* new_path, int flags, uv_fs_cb cb) {
+  UV__UNUSED(loop);
+  UV__UNUSED(req);
+  UV__UNUSED(path);
+  UV__UNUSED(new_path);
+  UV__UNUSED(flags);
+  UV__UNUSED(cb);
+  return UV_ENOSYS;
+}
+
+int uv_fs_mkdir(uv_loop_t* loop, uv_fs_t* req, const char* path, int mode, uv_fs_cb cb) {
+  wasi_fs_req_reset(req, loop, UV_FS_MKDIR, path, cb);
+  int rc = mkdir(path, mode);
+  req->result = (rc == 0) ? 0 : -errno;
+  if (cb) cb(req);
+  return cb ? 0 : (int)req->result;
+}
+
+int uv_fs_mkdtemp(uv_loop_t* loop, uv_fs_t* req, const char* tpl, uv_fs_cb cb) {
+  wasi_fs_req_reset(req, loop, UV_FS_MKDTEMP, tpl, cb);
+  if (!tpl) {
+    req->result = -EINVAL;
+    if (cb) cb(req);
+    return cb ? 0 : (int)req->result;
+  }
+  char* buf = strdup(tpl);
+  if (!buf) {
+    req->result = -ENOMEM;
+    if (cb) cb(req);
+    return cb ? 0 : (int)req->result;
+  }
+  if (!wasi_mkdtemp(buf)) {
+    req->result = -errno;
+    free(buf);
+  } else {
+    req->path = buf;
+    req->ptr = buf;
+    req->result = 0;
+  }
+  if (cb) cb(req);
+  return cb ? 0 : (int)req->result;
+}
+int uv_fs_mkstemp(uv_loop_t* loop, uv_fs_t* req, const char* tpl, uv_fs_cb cb) {
+  wasi_fs_req_reset(req, loop, UV_FS_MKSTEMP, tpl, cb);
+  if (!tpl) {
+    req->result = -EINVAL;
+    if (cb) cb(req);
+    return cb ? 0 : (int)req->result;
+  }
+  char* buf = strdup(tpl);
+  if (!buf) {
+    req->result = -ENOMEM;
+    if (cb) cb(req);
+    return cb ? 0 : (int)req->result;
+  }
+  int fd = wasi_mkstemp(buf);
+  if (fd < 0) {
+    req->result = -errno;
+    free(buf);
+  } else {
+    req->path = buf;
+    req->ptr = NULL;
+    req->result = fd;
+  }
+  if (cb) cb(req);
+  return cb ? 0 : (int)req->result;
+}
+int uv_fs_rmdir(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_fs_cb cb) {
+  wasi_fs_req_reset(req, loop, UV_FS_RMDIR, path, cb);
+  int rc = rmdir(path);
+  req->result = (rc == 0) ? 0 : -errno;
+  if (cb) cb(req);
+  return cb ? 0 : (int)req->result;
+}
+
+int uv_fs_scandir(uv_loop_t* loop, uv_fs_t* req, const char* path, int flags, uv_fs_cb cb) {
+  UV__UNUSED(loop);
+  UV__UNUSED(req);
+  UV__UNUSED(path);
+  UV__UNUSED(flags);
+  UV__UNUSED(cb);
+  return UV_ENOSYS;
+}
+
+int uv_fs_scandir_next(uv_fs_t* req, uv_dirent_t* ent) {
+  UV__UNUSED(req);
+  UV__UNUSED(ent);
+  return UV_ENOSYS;
+}
+
+int uv_fs_opendir(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_fs_cb cb) {
+  UV__UNUSED(loop);
+  UV__UNUSED(req);
+  UV__UNUSED(path);
+  UV__UNUSED(cb);
+  return UV_ENOSYS;
+}
+
+int uv_fs_readdir(uv_loop_t* loop, uv_fs_t* req, uv_dir_t* dir, uv_fs_cb cb) {
+  UV__UNUSED(loop);
+  UV__UNUSED(req);
+  UV__UNUSED(dir);
+  UV__UNUSED(cb);
+  return UV_ENOSYS;
+}
+
+int uv_fs_closedir(uv_loop_t* loop, uv_fs_t* req, uv_dir_t* dir, uv_fs_cb cb) {
+  UV__UNUSED(loop);
+  UV__UNUSED(req);
+  UV__UNUSED(dir);
+  UV__UNUSED(cb);
+  return UV_ENOSYS;
+}
+
+int uv_fs_stat(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_fs_cb cb) {
+  wasi_fs_req_reset(req, loop, UV_FS_STAT, path, cb);
+  struct stat st;
+  int rc = stat(path, &st);
+  if (rc == 0) {
+    wasi_stat_to_uv(&st, &req->statbuf);
+    req->result = 0;
+  } else {
+    req->result = -errno;
+  }
+  if (cb) cb(req);
+  return cb ? 0 : (int)req->result;
+}
+
+int uv_fs_fstat(uv_loop_t* loop, uv_fs_t* req, uv_file file, uv_fs_cb cb) {
+  wasi_fs_req_reset(req, loop, UV_FS_FSTAT, NULL, cb);
+  struct stat st;
+  int rc = fstat(file, &st);
+  if (rc == 0) {
+    wasi_stat_to_uv(&st, &req->statbuf);
+    req->result = 0;
+  } else {
+    req->result = -errno;
+  }
+  if (cb) cb(req);
+  return cb ? 0 : (int)req->result;
+}
+
+int uv_fs_rename(uv_loop_t* loop, uv_fs_t* req, const char* path, const char* new_path, uv_fs_cb cb) {
+  wasi_fs_req_reset(req, loop, UV_FS_RENAME, path, cb);
+  int rc = rename(path, new_path);
+  req->result = (rc == 0) ? 0 : -errno;
+  if (cb) cb(req);
+  return cb ? 0 : (int)req->result;
+}
+
+int uv_fs_fsync(uv_loop_t* loop, uv_fs_t* req, uv_file file, uv_fs_cb cb) {
+  wasi_fs_req_reset(req, loop, UV_FS_FSYNC, NULL, cb);
+  int rc = fsync(file);
+  req->result = (rc == 0) ? 0 : -errno;
+  if (cb) cb(req);
+  return cb ? 0 : (int)req->result;
+}
+
+int uv_fs_fdatasync(uv_loop_t* loop, uv_fs_t* req, uv_file file, uv_fs_cb cb) {
+  wasi_fs_req_reset(req, loop, UV_FS_FDATASYNC, NULL, cb);
+  int rc = fsync(file);
+  req->result = (rc == 0) ? 0 : -errno;
+  if (cb) cb(req);
+  return cb ? 0 : (int)req->result;
+}
+
+int uv_fs_ftruncate(uv_loop_t* loop, uv_fs_t* req, uv_file file, int64_t offset, uv_fs_cb cb) {
+  wasi_fs_req_reset(req, loop, UV_FS_FTRUNCATE, NULL, cb);
+  int rc = ftruncate(file, offset);
+  req->result = (rc == 0) ? 0 : -errno;
+  if (cb) cb(req);
+  return cb ? 0 : (int)req->result;
+}
+
+int uv_fs_sendfile(uv_loop_t* loop, uv_fs_t* req, uv_file out_fd, uv_file in_fd, int64_t in_offset, size_t length, uv_fs_cb cb) {
+  UV__UNUSED(loop);
+  UV__UNUSED(req);
+  UV__UNUSED(out_fd);
+  UV__UNUSED(in_fd);
+  UV__UNUSED(in_offset);
+  UV__UNUSED(length);
+  UV__UNUSED(cb);
+  return UV_ENOSYS;
+}
+
+int uv_fs_access(uv_loop_t* loop, uv_fs_t* req, const char* path, int mode, uv_fs_cb cb) {
+  wasi_fs_req_reset(req, loop, UV_FS_ACCESS, path, cb);
+  int rc = access(path, mode);
+  req->result = (rc == 0) ? 0 : -errno;
+  if (cb) cb(req);
+  return cb ? 0 : (int)req->result;
+}
+
+int uv_fs_chmod(uv_loop_t* loop, uv_fs_t* req, const char* path, int mode, uv_fs_cb cb) {
+  UV__UNUSED(loop);
+  UV__UNUSED(req);
+  UV__UNUSED(path);
+  UV__UNUSED(mode);
+  UV__UNUSED(cb);
+  return UV_ENOSYS;
+}
+
+int uv_fs_utime(uv_loop_t* loop, uv_fs_t* req, const char* path, double atime, double mtime, uv_fs_cb cb) {
+  UV__UNUSED(loop);
+  UV__UNUSED(req);
+  UV__UNUSED(path);
+  UV__UNUSED(atime);
+  UV__UNUSED(mtime);
+  UV__UNUSED(cb);
+  return UV_ENOSYS;
+}
+
+int uv_fs_futime(uv_loop_t* loop, uv_fs_t* req, uv_file file, double atime, double mtime, uv_fs_cb cb) {
+  UV__UNUSED(loop);
+  UV__UNUSED(req);
+  UV__UNUSED(file);
+  UV__UNUSED(atime);
+  UV__UNUSED(mtime);
+  UV__UNUSED(cb);
+  return UV_ENOSYS;
+}
+
+int uv_fs_lutime(uv_loop_t* loop, uv_fs_t* req, const char* path, double atime, double mtime, uv_fs_cb cb) {
+  UV__UNUSED(loop);
+  UV__UNUSED(req);
+  UV__UNUSED(path);
+  UV__UNUSED(atime);
+  UV__UNUSED(mtime);
+  UV__UNUSED(cb);
+  return UV_ENOSYS;
+}
+
+int uv_fs_lstat(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_fs_cb cb) {
+  UV__UNUSED(loop);
+  UV__UNUSED(req);
+  UV__UNUSED(path);
+  UV__UNUSED(cb);
+  return UV_ENOSYS;
+}
+
+int uv_fs_link(uv_loop_t* loop, uv_fs_t* req, const char* path, const char* new_path, uv_fs_cb cb) {
+  UV__UNUSED(loop);
+  UV__UNUSED(req);
+  UV__UNUSED(path);
+  UV__UNUSED(new_path);
+  UV__UNUSED(cb);
+  return UV_ENOSYS;
+}
+
+int uv_fs_symlink(uv_loop_t* loop, uv_fs_t* req, const char* path, const char* new_path, int flags, uv_fs_cb cb) {
+  UV__UNUSED(loop);
+  UV__UNUSED(req);
+  UV__UNUSED(path);
+  UV__UNUSED(new_path);
+  UV__UNUSED(flags);
+  UV__UNUSED(cb);
+  return UV_ENOSYS;
+}
+
+int uv_fs_readlink(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_fs_cb cb) {
+  UV__UNUSED(loop);
+  UV__UNUSED(req);
+  UV__UNUSED(path);
+  UV__UNUSED(cb);
+  return UV_ENOSYS;
+}
+
+int uv_fs_realpath(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_fs_cb cb) {
+  UV__UNUSED(loop);
+  UV__UNUSED(req);
+  UV__UNUSED(path);
+  UV__UNUSED(cb);
+  return UV_ENOSYS;
+}
+
+int uv_fs_fchmod(uv_loop_t* loop, uv_fs_t* req, uv_file file, int mode, uv_fs_cb cb) {
+  UV__UNUSED(loop);
+  UV__UNUSED(req);
+  UV__UNUSED(file);
+  UV__UNUSED(mode);
+  UV__UNUSED(cb);
+  return UV_ENOSYS;
+}
+
+int uv_fs_chown(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_uid_t uid, uv_gid_t gid, uv_fs_cb cb) {
+  UV__UNUSED(loop);
+  UV__UNUSED(req);
+  UV__UNUSED(path);
+  UV__UNUSED(uid);
+  UV__UNUSED(gid);
+  UV__UNUSED(cb);
+  return UV_ENOSYS;
+}
+
+int uv_fs_fchown(uv_loop_t* loop, uv_fs_t* req, uv_file file, uv_uid_t uid, uv_gid_t gid, uv_fs_cb cb) {
+  UV__UNUSED(loop);
+  UV__UNUSED(req);
+  UV__UNUSED(file);
+  UV__UNUSED(uid);
+  UV__UNUSED(gid);
+  UV__UNUSED(cb);
+  return UV_ENOSYS;
+}
+
+int uv_fs_lchown(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_uid_t uid, uv_gid_t gid, uv_fs_cb cb) {
+  UV__UNUSED(loop);
+  UV__UNUSED(req);
+  UV__UNUSED(path);
+  UV__UNUSED(uid);
+  UV__UNUSED(gid);
+  UV__UNUSED(cb);
+  return UV_ENOSYS;
+}
+
+int uv_fs_statfs(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_fs_cb cb) {
+  UV__UNUSED(loop);
+  UV__UNUSED(req);
+  UV__UNUSED(path);
+  UV__UNUSED(cb);
+  return UV_ENOSYS;
+}
+
+int uv_fs_poll_init(uv_loop_t* loop, uv_fs_poll_t* handle) {
+  UV__UNUSED(loop);
+  UV__UNUSED(handle);
+  return UV_ENOSYS;
+}
+
+int uv_fs_poll_start(uv_fs_poll_t* handle, uv_fs_poll_cb poll_cb, const char* path, unsigned int interval) {
+  UV__UNUSED(handle);
+  UV__UNUSED(poll_cb);
+  UV__UNUSED(path);
+  UV__UNUSED(interval);
+  return UV_ENOSYS;
+}
+
+int uv_fs_poll_stop(uv_fs_poll_t* handle) {
+  UV__UNUSED(handle);
+  return UV_ENOSYS;
+}
+
+int uv_fs_poll_getpath(uv_fs_poll_t* handle, char* buffer, size_t* size) {
+  UV__UNUSED(handle);
+  UV__UNUSED(buffer);
+  UV__UNUSED(size);
+  return UV_ENOSYS;
+}
+
+int uv_signal_init(uv_loop_t* loop, uv_signal_t* handle) {
+  UV__UNUSED(loop);
+  UV__UNUSED(handle);
+  return UV_ENOSYS;
+}
+
+int uv_signal_start(uv_signal_t* handle, uv_signal_cb signal_cb, int signum) {
+  UV__UNUSED(handle);
+  UV__UNUSED(signal_cb);
+  UV__UNUSED(signum);
+  return UV_ENOSYS;
+}
+
+int uv_signal_start_oneshot(uv_signal_t* handle, uv_signal_cb signal_cb, int signum) {
+  UV__UNUSED(handle);
+  UV__UNUSED(signal_cb);
+  UV__UNUSED(signum);
+  return UV_ENOSYS;
+}
+
+int uv_signal_stop(uv_signal_t* handle) {
+  UV__UNUSED(handle);
+  return UV_ENOSYS;
+}
+
+void uv_loadavg(double avg[3]) {
+  UV__UNUSED(avg);
+}
+
+int uv_fs_event_init(uv_loop_t* loop, uv_fs_event_t* handle) {
+  UV__UNUSED(loop);
+  UV__UNUSED(handle);
+  return UV_ENOSYS;
+}
+
+int uv_fs_event_start(uv_fs_event_t* handle, uv_fs_event_cb cb, const char* path, unsigned int flags) {
+  UV__UNUSED(handle);
+  UV__UNUSED(cb);
+  UV__UNUSED(path);
+  UV__UNUSED(flags);
+  return UV_ENOSYS;
+}
+
+int uv_fs_event_stop(uv_fs_event_t* handle) {
+  UV__UNUSED(handle);
+  return UV_ENOSYS;
+}
+
+int uv_fs_event_getpath(uv_fs_event_t* handle, char* buffer, size_t* size) {
+  UV__UNUSED(handle);
+  UV__UNUSED(buffer);
+  UV__UNUSED(size);
+  return UV_ENOSYS;
+}
+
+int uv_ip4_addr(const char* ip, int port, struct sockaddr_in* addr) {
+  UV__UNUSED(ip);
+  UV__UNUSED(port);
+  UV__UNUSED(addr);
+  return UV_ENOSYS;
+}
+
+int uv_ip6_addr(const char* ip, int port, struct sockaddr_in6* addr) {
+  UV__UNUSED(ip);
+  UV__UNUSED(port);
+  UV__UNUSED(addr);
+  return UV_ENOSYS;
+}
+
+int uv_ip4_name(const struct sockaddr_in* src, char* dst, size_t size) {
+  UV__UNUSED(src);
+  UV__UNUSED(dst);
+  UV__UNUSED(size);
+  return UV_ENOSYS;
+}
+
+int uv_ip6_name(const struct sockaddr_in6* src, char* dst, size_t size) {
+  UV__UNUSED(src);
+  UV__UNUSED(dst);
+  UV__UNUSED(size);
+  return UV_ENOSYS;
+}
+
+int uv_ip_name(const struct sockaddr* src, char* dst, size_t size) {
+  UV__UNUSED(src);
+  UV__UNUSED(dst);
+  UV__UNUSED(size);
+  return UV_ENOSYS;
+}
+
+int uv_inet_ntop(int af, const void* src, char* dst, size_t size) {
+  UV__UNUSED(af);
+  UV__UNUSED(src);
+  UV__UNUSED(dst);
+  UV__UNUSED(size);
+  return UV_ENOSYS;
+}
+
+int uv_inet_pton(int af, const char* src, void* dst) {
+  UV__UNUSED(af);
+  UV__UNUSED(src);
+  UV__UNUSED(dst);
+  return UV_ENOSYS;
+}
+
+int uv_random(uv_loop_t* loop, uv_random_t* req, void *buf, size_t buflen, unsigned flags, /* For future extension; must be 0. */ uv_random_cb cb) {
+  UV__UNUSED(loop);
+  UV__UNUSED(req);
+  UV__UNUSED(buf);
+  UV__UNUSED(buflen);
+  UV__UNUSED(flags);
+  UV__UNUSED(cb);
+  return UV_ENOSYS;
+}
+
+int uv_if_indextoname(unsigned int ifindex, char* buffer, size_t* size) {
+  UV__UNUSED(ifindex);
+  UV__UNUSED(buffer);
+  UV__UNUSED(size);
+  return UV_ENOSYS;
+}
+
+int uv_if_indextoiid(unsigned int ifindex, char* buffer, size_t* size) {
+  UV__UNUSED(ifindex);
+  UV__UNUSED(buffer);
+  UV__UNUSED(size);
+  return UV_ENOSYS;
+}
+
+int uv_exepath(char* buffer, size_t* size) {
+  UV__UNUSED(buffer);
+  UV__UNUSED(size);
+  return UV_ENOSYS;
+}
+
+int uv_cwd(char* buffer, size_t* size) {
+  UV__UNUSED(buffer);
+  UV__UNUSED(size);
+  return UV_ENOSYS;
+}
+
+int uv_chdir(const char* dir) {
+  UV__UNUSED(dir);
+  return UV_ENOSYS;
+}
+
+uint64_t uv_get_free_memory(void) {
+  return 0;
+}
+
+uint64_t uv_get_total_memory(void) {
+  return 0;
+}
+
+uint64_t uv_get_constrained_memory(void) {
+  return 0;
+}
+
+uint64_t uv_get_available_memory(void) {
+  return 0;
+}
+
+int uv_clock_gettime(uv_clock_id clock_id, uv_timespec64_t* ts) {
+  struct timespec t;
+  if (clock_gettime(clock_id == UV_CLOCK_MONOTONIC ? CLOCK_MONOTONIC : CLOCK_REALTIME, &t) != 0) {
+    return UV_EINVAL;
+  }
+  if (ts) {
+    ts->tv_sec = t.tv_sec;
+    ts->tv_nsec = t.tv_nsec;
+  }
+  return 0;
+}
+
+uint64_t uv_hrtime(void) {
+  struct timespec t;
+  if (clock_gettime(CLOCK_MONOTONIC, &t) != 0) {
+    return 0;
+  }
+  return (uint64_t)t.tv_sec * 1000000000ULL + (uint64_t)t.tv_nsec;
+}
+
+void uv_sleep(unsigned int msec) {
+  usleep(msec * 1000);
+}
+
+void uv_disable_stdio_inheritance(void) {
+  // noop stub
+}
+
+int uv_dlopen(const char* filename, uv_lib_t* lib) {
+  UV__UNUSED(filename);
+  UV__UNUSED(lib);
+  return UV_ENOSYS;
+}
+
+void uv_dlclose(uv_lib_t* lib) {
+  UV__UNUSED(lib);
+}
+
+int uv_dlsym(uv_lib_t* lib, const char* name, void** ptr) {
+  UV__UNUSED(lib);
+  UV__UNUSED(name);
+  UV__UNUSED(ptr);
+  return UV_ENOSYS;
+}
+
+const char* uv_dlerror(const uv_lib_t* lib) {
+  UV__UNUSED(lib);
+  return NULL;
+}
+
+int uv_mutex_init(uv_mutex_t* handle) {
+  if (!handle) return UV_EINVAL;
+  return 0;
+}
+
+int uv_mutex_init_recursive(uv_mutex_t* handle) {
+  if (!handle) return UV_EINVAL;
+  return 0;
+}
+
+void uv_mutex_destroy(uv_mutex_t* handle) {
+  UV__UNUSED(handle);
+}
+
+void uv_mutex_lock(uv_mutex_t* handle) {
+  UV__UNUSED(handle);
+}
+
+int uv_mutex_trylock(uv_mutex_t* handle) {
+  if (!handle) return UV_EINVAL;
+  return 0;
+}
+
+void uv_mutex_unlock(uv_mutex_t* handle) {
+  UV__UNUSED(handle);
+}
+
+int uv_rwlock_init(uv_rwlock_t* rwlock) {
+  UV__UNUSED(rwlock);
+  return UV_ENOSYS;
+}
+
+void uv_rwlock_destroy(uv_rwlock_t* rwlock) {
+  UV__UNUSED(rwlock);
+}
+
+void uv_rwlock_rdlock(uv_rwlock_t* rwlock) {
+  UV__UNUSED(rwlock);
+}
+
+int uv_rwlock_tryrdlock(uv_rwlock_t* rwlock) {
+  UV__UNUSED(rwlock);
+  return UV_ENOSYS;
+}
+
+void uv_rwlock_rdunlock(uv_rwlock_t* rwlock) {
+  UV__UNUSED(rwlock);
+}
+
+void uv_rwlock_wrlock(uv_rwlock_t* rwlock) {
+  UV__UNUSED(rwlock);
+}
+
+int uv_rwlock_trywrlock(uv_rwlock_t* rwlock) {
+  UV__UNUSED(rwlock);
+  return UV_ENOSYS;
+}
+
+void uv_rwlock_wrunlock(uv_rwlock_t* rwlock) {
+  UV__UNUSED(rwlock);
+}
+
+int uv_sem_init(uv_sem_t* sem, unsigned int value) {
+  UV__UNUSED(sem);
+  UV__UNUSED(value);
+  return UV_ENOSYS;
+}
+
+void uv_sem_destroy(uv_sem_t* sem) {
+  UV__UNUSED(sem);
+}
+
+void uv_sem_post(uv_sem_t* sem) {
+  UV__UNUSED(sem);
+}
+
+void uv_sem_wait(uv_sem_t* sem) {
+  UV__UNUSED(sem);
+}
+
+int uv_sem_trywait(uv_sem_t* sem) {
+  UV__UNUSED(sem);
+  return UV_ENOSYS;
+}
+
+int uv_cond_init(uv_cond_t* cond) {
+  UV__UNUSED(cond);
+  return UV_ENOSYS;
+}
+
+void uv_cond_destroy(uv_cond_t* cond) {
+  UV__UNUSED(cond);
+}
+
+void uv_cond_signal(uv_cond_t* cond) {
+  UV__UNUSED(cond);
+}
+
+void uv_cond_broadcast(uv_cond_t* cond) {
+  UV__UNUSED(cond);
+}
+
+int uv_barrier_init(uv_barrier_t* barrier, unsigned int count) {
+  UV__UNUSED(barrier);
+  UV__UNUSED(count);
+  return UV_ENOSYS;
+}
+
+void uv_barrier_destroy(uv_barrier_t* barrier) {
+  UV__UNUSED(barrier);
+}
+
+int uv_barrier_wait(uv_barrier_t* barrier) {
+  UV__UNUSED(barrier);
+  return UV_ENOSYS;
+}
+
+void uv_cond_wait(uv_cond_t* cond, uv_mutex_t* mutex) {
+  UV__UNUSED(cond);
+  UV__UNUSED(mutex);
+}
+
+int uv_cond_timedwait(uv_cond_t* cond, uv_mutex_t* mutex, uint64_t timeout) {
+  UV__UNUSED(cond);
+  UV__UNUSED(mutex);
+  UV__UNUSED(timeout);
+  return UV_ENOSYS;
+}
+
+void uv_once(uv_once_t* guard, void (*callback)(void)) {
+  // Best-effort one-shot; WASI build is single-threaded.
+  if (guard && guard->ran) {
+    return;
+  }
+  if (callback) {
+    callback();
+  }
+  if (guard) {
+    guard->ran = 1;
+  }
+}
+
+int uv_key_create(uv_key_t* key) {
+  // No TLS in this build; pretend success.
+  if (key) {
+    memset(key, 0, sizeof(*key));
+  }
+  return 0;
+}
+
+void uv_key_delete(uv_key_t* key) {
+  UV__UNUSED(key);
+}
+
+void* uv_key_get(uv_key_t* key) {
+  UV__UNUSED(key);
+  return NULL;
+}
+
+void uv_key_set(uv_key_t* key, void* value) {
+  UV__UNUSED(key);
+  UV__UNUSED(value);
+}
+
+int uv_gettimeofday(uv_timeval64_t* tv) {
+  if (!tv) {
+    return UV_EINVAL;
+  }
+  struct timespec ts;
+  if (clock_gettime(CLOCK_REALTIME, &ts) != 0) {
+    return -errno;
+  }
+  tv->tv_sec = ts.tv_sec;
+  tv->tv_usec = ts.tv_nsec / 1000;
+  return 0;
+}
+
+int uv_thread_create(uv_thread_t* tid, uv_thread_cb entry, void* arg) {
+  // Threads unsupported in this WASI build.
+  UV__UNUSED(tid);
+  UV__UNUSED(entry);
+  UV__UNUSED(arg);
+  return UV_ENOSYS;
+}
+
+int uv_thread_detach(uv_thread_t* tid) {
+  UV__UNUSED(tid);
+  return UV_ENOSYS;
+}
+
+int uv_thread_create_ex(uv_thread_t* tid, const uv_thread_options_t* params, uv_thread_cb entry, void* arg) {
+  UV__UNUSED(tid);
+  UV__UNUSED(params);
+  UV__UNUSED(entry);
+  UV__UNUSED(arg);
+  return UV_ENOSYS;
+}
+
+int uv_thread_setaffinity(uv_thread_t* tid, char* cpumask, char* oldmask, size_t mask_size) {
+  UV__UNUSED(tid);
+  UV__UNUSED(cpumask);
+  UV__UNUSED(oldmask);
+  UV__UNUSED(mask_size);
+  return UV_ENOSYS;
+}
+
+int uv_thread_getaffinity(uv_thread_t* tid, char* cpumask, size_t mask_size) {
+  UV__UNUSED(tid);
+  UV__UNUSED(cpumask);
+  UV__UNUSED(mask_size);
+  return UV_ENOSYS;
+}
+
+int uv_thread_getcpu(void) {
+  return UV_ENOSYS;
+}
+
+uv_thread_t uv_thread_self(void) {
+  uv_thread_t out; memset(&out, 0, sizeof(out)); return out;
+}
+
+int uv_thread_join(uv_thread_t *tid) {
+  UV__UNUSED(tid);
+  return UV_ENOSYS;
+}
+
+int uv_thread_equal(const uv_thread_t* t1, const uv_thread_t* t2) {
+  UV__UNUSED(t1);
+  UV__UNUSED(t2);
+  return UV_ENOSYS;
+}
+
+int uv_thread_setname(const char* name) {
+  UV__UNUSED(name);
+  return UV_ENOSYS;
+}
+
+int uv_thread_getname(uv_thread_t* tid, char* name, size_t size) {
+  UV__UNUSED(tid);
+  UV__UNUSED(name);
+  UV__UNUSED(size);
+  return UV_ENOSYS;
+}
+
+void* uv_loop_get_data(const uv_loop_t* arg0) {
+  UV__UNUSED(arg0);
+  return NULL;
+}
+
+void uv_loop_set_data(uv_loop_t* arg0, void* data) {
+  UV__UNUSED(arg0);
+  UV__UNUSED(data);
+}
+
+size_t uv_utf16_length_as_wtf8(const uint16_t* utf16, ssize_t utf16_len) {
+  UV__UNUSED(utf16);
+  UV__UNUSED(utf16_len);
+  return 0;
+}
+
+int uv_utf16_to_wtf8(const uint16_t* utf16, ssize_t utf16_len, char** wtf8_ptr, size_t* wtf8_len_ptr) {
+  UV__UNUSED(utf16);
+  UV__UNUSED(utf16_len);
+  UV__UNUSED(wtf8_ptr);
+  UV__UNUSED(wtf8_len_ptr);
+  return UV_ENOSYS;
+}
+
+ssize_t uv_wtf8_length_as_utf16(const char* wtf8) {
+  UV__UNUSED(wtf8);
+  return 0;
+}
+
+void uv_wtf8_to_utf16(const char* wtf8, uint16_t* utf16, size_t utf16_len) {
+  UV__UNUSED(wtf8);
+  UV__UNUSED(utf16);
+  UV__UNUSED(utf16_len);
+}
